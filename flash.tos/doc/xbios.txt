*************************************************************************
 CT60 XBIOS functions v1.04
*************************************************************************
XBIOS Functions list:

ct60_read_core_temperature() XBIOS function 0xc60a.
ct60_rw_parameter()          XBIOS Function 0xc60b.
ct60_cache()                 XBIOS Function 0xc60c.
ct60_flush_cache()           XBIOS Function 0xc60d.
ct60_vmalloc                 XBIOS Function 0xc60e, Radeon driver.
Vsetscreen()                 XBIOS Function 5, Radeon driver
CacheCtrl()                  XBIOS Function 160.

*************************************************************************
				ct60_read_core_temperature    
*************************************************************************

  Opcode:
       XBIOS 0xc60a

  Syntax:
       long ct60_read_core_temperature(short type_deg);

  Description:
          Read the 68060 temperature.

  type_deg:
          CT60_CELCIUS 0
          CT60_FARENHEIT 1  
  
  Binding:
          move.w  type_deg,-(sp)
          move.w  #$c60a,-(sp)
          trap    #14
          addq.l  #4,sp
          
  Return: The value or ERROR (-1) if there is a read error.

*************************************************************************
				ct60_rw_parameter
*************************************************************************

  Opcode:
       XBIOS 0xc60b

  Syntax:
       long ct60_rw_parameter(short mode,long type_param,long value);

  Description:
          Read or write a parameter inside the flash eprom.
          The fonction returns the value.
          
  mode:
          CT60_MODE_READ 0
          The value is read.
          
          CT60_MODE_WRITE 1
          The value is write.

  type_param:     
          CT60_BLITTER_SPEED 1
          If the value is set to 0, the blitter runs at 8/10 MHz.
          If the value is set to 1, the blitter runs at 16/20 MHz.          

          CT60_CACHE_DELAY 2
          If the bit 0 of the value is cleared, the Pexec function is 
          normal (flushes cache).
          If the bit 0 of the value is set, the caches are disabled
          for 5 seconds when a program is started under TOS with the
          Pexec function.
          If the bit 1 of the value is set, there are an Fread test
          and maybe a copyback alert if the code begin by $601A. With
          this alert you can remove the cache during 5 seconds.
          If the bit 1 of the value is cleared, there are no copyback
          alert.

          CT60_BOOT_ORDER 3
          New boot
          ========
          If the value is set to 0, TOS boots from SCSI drives (0-7) 
          before IDE drives (0-1).
          If the value is set to 1, TOS boots from IDE drives (0-1) 
          before SCSI drives (0-7).
          If the value is set to 2, TOS boots from SCSI drives (7-0) 
          before IDE drives (1-0).
          If the value is set to 3, TOS boots from IDE drives (1-0) 
          before SCSI drives (7-0).
          Old boot
          ========
          If the value is set to 4, TOS boots from SCSI drives (0-7) 
          before IDE drives (0-1).
          If the value is set to 5, TOS boots from IDE drives (0-1) 
          before SCSI drives (0-7).
          If the value is set to 6, TOS boots from SCSI drives (7-0) 
          before IDE drives (1-0).
          If the value is set to 7, TOS boots from IDE drives (1-0) 
          before SCSI drives (7-0).
          
          CT60_CPU_FPU 4
          If the bit 0 of the value is cleared, the FPU is disabled.

          CT60_BOOT_LOG 5
          If the bit 0 is cleared, the stdout output of the AUTO 
          folder files is writed inside a boot.log on the boot drive.
          If the bit 1 is cleared, the stdout debug output of the 
          internal fVDI driver is selected and writed inside a 
          video.log on the boot drive.

          CT60_VMODE 6 
          Boot extended modecode for CTPCI graphic card:
          F030 modecode + extended bits:
           HORFLAG   0x200 for double width
           HORFLAG2  0x400 for width increased
           VESA_600  0x800 for SVGA 600
           VESA_768  0x1000 for SVGA 768
           VERTFLAG2 0x2000 for double height
           BPS32     5 for True Color

          CT60_SAVE_NVRAM_1 7
          CT60_SAVE_NVRAM_2 8
          CT60_SAVE_NVRAM_3 9
          Reserved for TOS NVM backup, do not use.

          CT60_PARAM_OFFSET_TLV 10
          Value contains a signed offset in points.  A point is equal 
          to 2.8 øC.

          CT60_USER_DIV_CLOCK 12
          CTCM secondary user clock divider (2-6). The clock frequency  
          on the secondary user clock is the clock frequency / divider.
          For example for create a new PCI clock or a Videl external 
          clock.
          If the value is invalid, the TOS calculate a value for get a 
          secondary clock <= 33000 KHz.
          If CT60_CLOCK parameter value is <= 66000 the TOS set the 
          divider to 2.

          CT60_CLOCK 13
          CTCM boot clock frequency in KHz (65000-110000)
          WARNING, if you increase frequency !!!
         
          CT60_PARAM_CTPCI 14
          If the bit 0 of the value is cleared, the TOS boot on the 
          native F030 IDE port.
          If the bit 0 of the value is set, the TOS boot n the CTPCI 
          IDE port who replaces the F030 at the same address.
          If the bit 1 of the value is cleared, the VDI not use the 
          CTPCI PLX DMA (slower for vro_cpyfm).
          If the bit 1 of the value is set, the VDI use the CTPCI PLX 
          DMA (faster for vro_cpyfm).
          

  Binding:
          move.l  value,-(sp)
          move.l  type_param,-(sp)
          move.w  mode,-(sp)
          move.w  #$c60b,-(sp)
          trap    #14
          lea     12(sp),sp

  Return: The value or:
          EBADRQ (-5) if the parameter is >= 15. 
          EWRITF (-10) for a write fault.
          EUNDEV (-15) if the flash device is not found.

*************************************************************************
				ct60_cache
*************************************************************************

  Opcode:   
       XBIOS 0xc60c

 Syntax:
       long ct60_cache(short cache_mode);

  Description:
          This function is used to enable or disable the 68060 caches 
          in the patched version of General.cpx.
          
  cache_mode:
          1 enable the caches.
          0 disable the caches.
          -1 no change.

  Binding:
          move.w  cache_mode,-(sp)
          move.w  #$c60c,-(sp)
          trap    #14
          addq.l  #4,sp

  Return: Returns the contents of the CACR.
  
  Note: For normal programs, the CacheCtrl() function is preferred.

*************************************************************************
				ct60_flush_cache
*************************************************************************

  Opcode:
       XBIOS 0xc60d

  Syntax:
       long ct60_flush_cache(void);

  Description:
          This function is used to flush the instruction and data 
          caches in the patched version of Xcontrol.

  Binding:
          move.w  #$c60d,-(sp)
          trap    #14
          addq.l  #2,sp

  Return: ct60_flush_cache returns E_OK (0).

  Note: For normal programs, the CacheCtrl() function is preferred.

*************************************************************************
			ct60_vmalloc (Radeon driver)
*************************************************************************

  Opcode:
       XBIOS 0xc60e

  Syntax:
       long ct60_vmalloc(short mode, long value);

  Description:
          This function is used to allocate momory inse the offscreen area.

  mode:
          mode = 0, value <=> malloc size, return address or null if memory full.
          mode = 1, value <=> address of previous malloc.
          mode = 2, null value for init (normally never used excepted by radeon.sys).

  Binding:
          move.l  value,-(sp)
          move.w  mode,-(sp)
          move.w  #$c60e,-(sp)
          trap    #14
          addq.l  #8,sp

  Return: Returns address or null if memory full.

  Note: Only valid with internal TOS Radeon driver (PCI.HEX).

*************************************************************************
			Vsetscreen (Radeon driver)
*************************************************************************

  Opcode:
       XBIOS 5

  Syntax:
       void Vsetscreen(void *par1, void *par2, short rez, short command);

  Description:
          This function is nearest the MilanTOS, it's an extended call of Vsetscreen.  
          There are some differences:
          - rez is always at 0x564E ('VN' for Vsetscreen New), an invalid modecode.
          - devId used below inside a structure is just the modecode.
          You can use this function like the TOS:
          Vsetscreen(long logaddr, long physaddr, short rez, short modecode);
          some flags inside modecode are added:

#define HORFLAG         0x200 /* double width */
#define HORFLAG2        0x400 /* width increased */
#define VESA_600        0x800 /* SVGA 600 lines */
#define VESA_768       0x1000 /* SVGA 768 lines */
#define VERTFLAG2      0x2000 /* double height */
#define DEVID          0x4000 /* bits 11-3 used for devID */
#define VIRTUAL_SCREEN 0x8000 /* width * 2 and height * 2, 2048 x 2048 max */
#define BPS32 5

OVERSCAN and PAL flags are used for select refresh frequency:
 OVERSCAN | PAL | Freq
 ---------+-----+-----
        0 |  0  | 56
        0 |  1  | 60
        1 |  0  | 70
        1 |  1  | 85 

  par1: used or not by each command.   

  par2: used or not by each comm 

  rez: always 0x564E (Vsetscreen New) 

  command:

          CMD_GETMODE (0) Getting current mode

              long modecode;
              Vsetscreen(-1,&modecode,0x564E,CMD_GETMODE);
              This function is identical to Vsetmode(-1);

          CMD_SETMODE (1) Set new graphic mode

              long modecode=VESA_600+HORFLAG2+VGA+COL80+BPS32; /* 800*600*16M */
              Vsetscreen(-1,modecode,0x564E,CMD_SETMODE)

              This function is identical to Vsetscreen(0,0,3,modecode);
              BIOS and VDI are initialised.

          CMD_GETINFO (2) Get screen info structure for mode

              SCREENINFO si;
              si.size = sizeof(SCREENINFO); /* Structure size has to be set */
              si.devID = VESA_600+HORFLAG2+VGA+COL80+BPS32; /* 800*600*16M */
              /* mode or 0 for current mode */
              si.scrFlags=0; /* status of the operation */
              Vsetscreen(-1,&si,0x564E,CMD_GETINFO);
              if(si.scrFlags & SCRINFO_OK)
                puts("OK");
              else
                puts("Error");

          CMD_ALLOCPAGE (3) Allocate screenpage

              long addr=0; /* Frame address or -1 */
              Vsetscreen(&addr,modecode,0x564E,CMD_ALLOCPAGE);
              if(addr)
                puts("OK");
              else
                puts("Error");

              This only allocates one page. A further call will only 
              return the frame address. 

          CMD_FREEPAGE (4) Release screenpage

              Vsetscreen(-1,-1,0x564E,CMD_FREEPAGE);

              The graphics card memory will be released again. If the 
              second page had still been active the call will switch
              back to the first page with Logbase and Physbase set.

          CMD_FLIPPAGE (5) Switch screenpage

              Vsetscreen(-1,-1,0x564E,CMD_FLIPPAGE);

              Will switch to the second screenpage.
              Logbase and Physbase will be set.

          CMD_ALLOCMEM (6) Allocate memory on the graphics card

              SCRMEMBLK blk;
              blk.size=sizeof(SCRMEMBLK);
              blk.blk_y=200; /* alloc a block of 200 lines*/
              Vsetscreen(-1,&blk,0x564E,CMD_ALLOCMEM);
              if(blk.blk_start)
                puts("OK");
              else
                puts("Out of memory");
              
              The width of the block is currently always the width of 
              the virtual screen. For the hardware functions this block
              will be like a screen (0,0,blk_w,blk_h), the coordinates 
              start in the top left corner (0,0). It will be internally
              recalculated.

          CMD_FREEMEM (7) Release graphics card memory

              Vsetscreen(-1,&blk,0x564E,CMD_FREEMEM);

              blk of the block to be released.

          CMD_SETADR (8) Set screen to fixed address

              long logbase=blk.blk_start;  /* logical address or -1  */
              long physbase=blk.blk_start; /* physical address or -1 */
              Vsetscreen(logbase,physbase,0x564E,CMD_SETADR);
                          
              This function is identical to Vsetscreen(logbase,physbase,-1,-1);

          CMD_ENUMMODES (9) Requests all available modes

              long cdecl enumfunc(SCREENINFO *inf,long flag)
              {
                printf("%s\n",inf->name);
                return ENUMMODE_CONT;
              }
              Vsetscreen(-1,&enumfunc,0x564E,CMD_ENUMMODES);

              The function "enumfunc" will be called once for every 
              available mode. ENUMMODE_EXIT (0) will cancel 
              CMD_ENUMMODES. ENUMMODE_CONT (1) will continue. The 
              parameters are handed over to the stack using the C 
              standard. flag is undocumented inside the MilanTOS.

          CMD_TESTMODE (10) Test a graphic mode

              long modecode=VESA_600+HORFLAG2+VGA+COL80+BPS32; /* 800*600*16M */
              Vsetscreen(-1,modecode,0x564E,CMD_TESTMODE);

              Only the BIOS is initialised, and a screen test arrives 
              with colored wide lines. This function not exist inside 
              the MilanTOS.

          CMD_COPYPAGE (11) Copy screenpage
           
              Vsetscreen(-1,0,0x564E,CMD_COPYPAGE);
              Copy first screenpage to second screenpage
              Vsetscreen(-1,1,0x564E,CMD_COPYPAGE);
              Copy second screenpage to first screenpage        
              
              This function not exist inside the MilanTOS.

  Binding:
          move.w  command,-(sp)
          move.w  rez,-(sp)
          move.l  par2,-(sp)
          move.l  par1,-(sp)
          move.w  #5,-(sp)
          trap    #14
          lea     14(sp),sp

          or

          move.w  modecode,-(sp)
          move.w  rez,-(sp)
          move.l  physaddr,-(sp)
          move.l  logaddr,-(sp)
          move.w  #5,-(sp)
          trap    #14
          lea     14(sp),sp

  Return: nothing (or current modecode in TOS mode).

  Note: Only valid with internal TOS Radeon driver (PCI.HEX).

/* scrFlags */
#define SCRINFO_OK 1

/* scrClut */
#define NO_CLUT    0
#define HARD_CLUT  1
#define SOFT_CLUT  2

/* scrFormat */
#define INTERLEAVE_PLANES  0
#define STANDARD_PLANES    1
#define PACKEDPIX_PLANES   2

/* bitFlags */
#define STANDARD_BITS  1
#define FALCON_BITS    2
#define INTEL_BITS     8

typedef struct screeninfo
{
  long size;        /* Size of structure          */
  long devID;       /* modecode                   */
  char name[64];    /* Friendly name of Screen    */
  long scrFlags;    /* some Flags                 */
  long frameadr;    /* Address of framebuffer     */
  long scrHeight;   /* visible X res              */
  long scrWidth;    /* visible Y res              */
  long virtHeight;  /* virtual X res              */
  long virtWidth;   /* virtual Y res              */
  long scrPlanes;   /* color Planes               */
  long scrColors;   /* # of colors                */
  long lineWrap;    /* # of Bytes to next line    */
  long planeWarp;   /* # of Bytes to next plane   */
  long scrFormat;   /* screen Format              */
  long scrClut;     /* type of clut               */
  long redBits;     /* Mask of Red Bits           */
  long greenBits;   /* Mask of Green Bits         */
  long blueBits;    /* Mask of Blue Bits          */
  long alphaBits;   /* Mask of Alpha Bits         */
  long genlockBits; /* Mask of Genlock Bits       */
  long unusedBits;  /* Mask of unused Bits        */
  long bitFlags;    /* Bits organisation flags    */
  long maxmem;      /* max. memory in this mode   */
  long pagemem;     /* needed memory for one page */
  long max_x;       /* max. possible width        */
  long max_y;       /* max. possible heigth       */
} SCREENINFO;

#define BLK_ERR      0
#define BLK_OK       1
#define BLK_CLEARED  2

typedef struct _scrblk
{
  long size;                  /* size of structure                  */
  long blk_status;            /* status bits of blk                 */
  long blk_start;             /* Start Address                      */
  long blk_len;               /* length of memblk                   */
  long blk_x;                 /* x pos in total screen              */
  long blk_y;                 /* y pos in total screen              */
  long blk_w;                 /* width                              */
  long blk_h;                 /* height                             */
  long blk_wrap;              /* width in bytes                     */
} SCRMEMBLK;

*************************************************************************
				CacheCtrl
*************************************************************************

  Opcode:
       XBIOS 160

  Syntax:
       long CacheCtrl(short OpCode,short Param);

  Description:
          This function is compatible with MilanTOS.

  OpCode:
          OpCode  Param 
            0      -    return 0 to check that function is implemented.
            1      -    Flush Data Cache.
            2      -    Flush Instruction Cache.
            3      -    Flush Data and Instruction Cache.
            4      -    Inquire data cache mode.
            5     mode  Set data cache mode, invalidate/flush caches. 
            6      -    Inquire instruction cache mode.
            7     mode  Set instruction cache mode, invalidate/flush caches.
          with mode : 0 = disable / 1 = enable.

  Binding:
          move.w  Param,-(sp)
          move.w  OpCode,-(sp)
          move.w  #160,-(sp)
          trap    #14
          addq.l  #6,sp

  Return: Inquire value, E_OK (0) or BADRQ (-5) if the OpCode is > 7.

  Note: Under the CT60 XBIOS, OpCodes 5/7 have the same effect :
        mode : 0 = disable all caches.
               1 = enable all caches.
        All caches are : Data Cache, Store Buffer, Branch Cache, 
        Instruction Cache.

*************************************************************************
