*************************************************************************
-------------------------------------------------------------------------
*************************************************************************

 Generic Sound XBios programmers documentation v0.01
          adapted for the AC97 sound driver

Functions covered in this document;

Locksound()    XBIOS function 128.
Unlocksound()  XBIOS Function 129.
Soundcmd()     XBIOS Function 130.
Setbuffer()    XBIOS Function 131.
Setmode()      XBIOS Function 132.
Settracks()    XBIOS Function 133.
Setmontracks() XBIOS Function 134.
Setinterrupt() XBIOS Function 135.
Buffoper()     XBIOS Function 136.
Dsptristate()  XBIOS Function 137. Not yet implemented.
Gpio()         XBIOS Function 138.
Devconnect()   XBIOS Function 139.
Sndstatus()    XBIOS Function 140.
Buffptr()      XBIOS Function 141.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************

        <<>> Locksnd <<>> Locksnd <<>> Locksnd <<>> Locksnd <<>>

  Opcode:
       XBIOS 128

  Syntax:
       long Locksnd ( void );

  Description:
          When one intends to use the soundsystem, Locksnd() should be 
          called to prevent other clean applications from using the 
          soundsystem. All cleanly written applications call Locksnd() 
          before attempting to use the soundsystem, but unfortunately 
          there exists some that just plunge ahead.

          So, ALWAYS call Locksnd() before using the sound XBIOS!!!

  Binding:
          move.w  #128,-(sp)
          trap    #14
          addq.l  #2,sp
          
  Return: Locksnd() will return 1 if soundsystem was sucessfully locked, 
          or ESNDLOCKED if it is already locked by another application.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************

    <<>> Unlocksnd <<>> Unlocksnd <<>> Unlocksnd <<>> Unlocksnd <<>>

  Opcode:
       XBIOS 129

  Syntax:
       long Unlocksnd ( void );

  Description:
          When done using the soundsystem, call Unlocksnd() to free the 
          soundsystem. This will make other applications able to use it 
          again.

  Binding:
          move.w  #129,-(sp)
          trap    #14
          addq.l  #2,sp

  Return: Unlocksnd() will return E_OK if the soundsystem was 
          successfully unlocked, or ESNDNOTLOCK if it wasn't locked.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************

      <<>> Soundcmd <<>> Soundcmd <<>> Soundcmd <<>> Soundcmd <<>>


  Opcode:   
       XBIOS 130

 Syntax:
      long Soundcmd ( word Mode, word DATA );


  Description:
          Soundcmd() is the function used to control most of the things 
          relating to PCM sound, like setting DAC/ADC sampling rate, 
          selecting record sources, etc. Also it is used to disable(mute) 
          or enable(unmute) different mixer channels, setting record 
          gain, etc., etc..

          There are two forms of this function. One is the Falcon XBIOS 
          compatible call, and the other is the extended one, which takes 
          one extra parameter. Only the standard version of this call is 
          discussed below unless otherwise noted.

  Binding:

  normal:
          move.w  DATA,-(sp)
          move.w  Mode,-(sp)
          move.w  #130,-(sp)
          trap    #14
          addq.l  #6,sp
          
-------------------------------------------------------------------------

 Mode 0   Set Left PCM attenuation (DAC)
 Mode 1   Set Right PCM attenuation (DAC)

          These modes sets the attenuation for the DAC's Left/Right 
          channels.

  DATA:   attenuation (0 - 255) If DATA = SND_INQUIRE (-1), the current 
          setting will be returned without change.

  Return: Returns the value actually set, or ENODEV if installed driver 
                does not have PCM sound.

-------------------------------------------------------------------------

 Mode 2 - Set Record Gain Left channel (ADC)
 Mode 3 - Set Record Gain Right channel (ADC)

          These two modes set the record gain for the Left and Right ADC 
          channels.

  DATA:   Record Gain (0 - 255). If DATA = SND_INQUIRE (-1), the current 
          setting will be returned without change.

  Return: Returns the value actualy set, or ENODEV if installed
          driver can't do recording.

-------------------------------------------------------------------------

 Mode 4   Enable/disable (unmute/mute) different mixer channels.

          This mode is originally used to set the 16-bit ADDER to receive 
          its input from either sources specified in DATA. I'm not sure 
          what a 16-bit ADDRER is. In GSXB, this mode is used to turn 
          on/off (Unmute/Mute) individual mixer channels, including the 
          Master.

  DATA:   DATA is a bitmask specifying which mixer channels to 
          Enable/Disable. A SET bit enables/unmutes the corresponding 
          channel, a CLEARED bit disables/Mutes it.

          Bit 0 - ADC
          Bit 1 - Stereo Mixer (Master)
          To be able to enable or disable the channels below, bit #14 has 
          to be set in DATA. If bit #14 is cleared, the below channels 
          are unmodified.
          Bit 2 - Microphone In.
          Bit 3 - FM Generator, PC Beep / 3D enable on AC97.
          Bit 4 - Line In.
          Bit 5 - CD In.
          Bit 6 - Video/TV in.
          Bit 7 - Aux In.
          Bit 8 - PCM.

  Return: Returns the actual setting being done. This call does not 
          return any errors if the hardware driver does not support a 
          channel attempted enabled/disabled. Use Soundstatus() to obtain 
          a mask of currently available mixer channels. One can also 
          check the return of this call to verify if the wanted channel's 
          bit is set.

--------------------------------------------------------------------------

  Mode 5  Record source select. This mode is used to select a input 
          source for the ADC.

  DATA:   DATA is a bit mask of record sources. If DATA = SND_INQUIRE    
          (-1), no changes are made, and the current settings are 
          returned. This call works in two different ways. With Bit #14 
          in DATA cleared, it works as in the original Falcon XBIOS, 
          except that instead of selecting the Soundchip, Aux is 
          attempted selected. This is because the Soundchip is not 
          available as a record source with soundcards, except maybe if 
          you connect it to the Aux input.
          A SET bit will select Soundchip (Aux here), and a CLEARED bit 
          will select Microphone.

          Bit 0 - Right record channel source select.
          Bit 1 - Reft record channel source select.

          When DATA has bit #14 set, the bitmask is more straight 
          forward. Here a CLEARED bit selects a give input source, while 
          a SET bit unselects it.

          Bit 0  - Microphone    -> Right record channel.
          Bit 1  - Microphone    -> Left record channel.
          Bit 2  - FM Generator  -> Right record channel, not used on AC97.
          Bit 3  - FM Generator  -> Left record channel, not used on AC97.
          Bit 4  - Line In       -> Right record channel.
          Bit 5  - Line In       -> Left record channel.
          Bit 6  - CD In         -> Right record channel
          Bit 7  - CD In         -> Left record channel.
          Bit 8  - Video/TV In   -> Right record channel.
          Bit 9  - Video/TV In   -> Left record channel.
          Bit 10 - Aux In        -> Right record channel.
          Bit 11 - Aux In        -> Left record channel.
          Bit 12 - Master mix    -> Right record channel
          Bit 13 - Master mix    -> Left record channel.
          
          From this you might be tempted to select more than one source 
          for each channel, right? Wrong.. sort of. As far as the driver 
          I'm writing is concerned, it selects only one source per 
          channel. This means that if both bits 2 (FM) and bit 6 (CD) is 
          seleted (cleared) for the Right record channel, only the source 
          with the highest bit number will be selected, in this case the 
          CD. You can try to select more than one record source per 
          channel, but then you MUST check the return value to see if the 
          correct source was selected. And if not, select only one source 
          per channel.

  Return: If the driver does not support a record channel source, it will 
          return ENODEV, otherwise it returns the actual settings.

--------------------------------------------------------------------------

 Mode 6   SETPRESCALE. This mode is only valid (that is, it does nothing) 
          until after using Devconnect() to set the prescaler to TT030 
          compatibility mode. When that is done, DATA represents the 
          TT030 compatible prescaler values as follow;

          Name        Value    Meaning
          CCLK_6K       0        Divide by 1280 (6.25 KHz)
          CCLK_12K      1        Divide by  640 (12.5 KHz)
          CCLK_25K      2        Divide by  320 (25 KHz)
          CCLK_50K      3        Divide by  160 (50 KHz)

          If DATA = SND_INQUIRE (-1), the current prescale setting is 
          returned without any changes being done.

  NOTE:   Rate is set for both the DAC and ADC.

  Return: This mode returns the actual setting.

--------------------------------------------------------------------------

 Mode 7   Set Sample rate. This is a MilanBlaster/GSXB only mode, and is 
          is available when bits 2 AND 5 in _SND cookie is SET. If this 
          is true, always use this call to set desired sample rate.

  DATA:   If DATA = SND_INQUIRE (-1), the current sample rate is returned 
          without any changes. Otherwise DATA contains the desired sample 
          rate, between 0 - 65533 Hz.

  NOTE:   This call actually sets the rate for both the DAC and the ADC.

  Return: Returns the sample rate actually set for the DAC.

--------------------------------------------------------------------------

 Mode 8   Set desired format for 8-bit samples. This is a  
          MilanBlaster/GSXB only mode, and is is available when bits 2 
          AND 5 in _SND cookie is SET. This call is used to change the 
          format on 8-bit samples, as some hardware can support more 
          formats. It is up to the driver to allow sample formats that is 
          not supporte by hardware to be used. This means the driver does
          the conversion in software. 
          This is not good with programs that load a sound once, and 
          replay this several times, as the sample signs will be 
          "toggled" each time it is played.

  DATA:   If DATA = SND_INQUIRE (-1), the sampleformat currently in use 
          is returned. Otherwise DATA is a bitmask with the following 
          meaning;

          Bit 0 - If set, Signed
          Bit 1 - If set, Unsigned

          From this one might think that it is possible to set both 
          Signed and Unsigned sampleformat. If that is attempted, EBADARG 
          is returned. It is strongly recommended that Soundstatus(8) is 
          called to obtain supported sampleformats, and select desired 
          format accordingly!

  Return: Returns the format acutally set, or EBADARG if 
          attempting to set both signed/unsigned format. If the driver 
          does not support 8-bit samples, ENODEV is returned.
          The AC97 driver returns always 1 for Signed.

--------------------------------------------------------------------------

 Mode 9   Set desired format for 16-bit samples. This is a  
          MilanBlaster/GSXB only mode, and is is available when bits 2 
          AND 5 in _SND cookie is SET. This call is used to change the 
          format on 16-bit samples, as some hardware can support more 
          formats. It is up to the driver to allow sample formats that is 
          not supporte by hardware to be used. This means the driver does 
          the conversion in software. This is not good with programs that 
          load a sound once, and replay this several times, as the sample 
          signs/endianess will be "toggled" each time it is played.

  DATA:   If DATA = SND_INQUIRE (-1), the sampleformat currently in use 
          is returned. Otherwise DATA is a bitmask with the following 
          meaning;

          Bit 0 - If set, Signed
          Bit 1 - If set, Unsigned
          Bit 2 - If set, Big endian (motorola byte order)
          Bit 3 - If set, Little Endian (Intel byte order)

          From this one might think that it is possible to set both 
          Signed/Unsigned and/or Big/Little endian sampleformat. If that 
          is attempted, EBADARG is returned. It is strongly recommended 
          that Soundstatus(9) is called to obtain supported 
          sampleformats, and select desired format accordingly!

  Return: Returns the format acutally set, or EBADARG if 
          attempting to set both signed/unsigned and/or big/little endian 
          format. If the driver does not support 16-bit samples, ENODEV 
          is returned.
          The AC97 driver returns always 5 for Signed Big Endian.

--------------------------------------------------------------------------

 Mode 10  Set desired format for 24-bit samples. This is a  
          MilanBlaster/GSXB only mode, and is is available when bits 2 
          AND 5 in _SND cookie is SET. This call is used to change the 
          format on 24-bit samples, as some hardware can support more 
          formats. It is up to the driver to allow sample formats that is 
          not supporte by hardware to be used. 

  DATA:   If DATA = SND_INQUIRE (-1), the sampleformat currently in use 
          is returned. Otherwise DATA is a bitmask with the following 
          meaning;

          Bit 0 - If set, Signed
          Bit 1 - If set, Unsigned
          Bit 2 - If set, Big endian (motorola byte order)
          Bit 3 - If set, Little Endian (Intel byte order)

          From this one might think that it is possible to set both 
          Signed/Unsigned and/or Big/Little endian sampleformat. If that 
          is attempted, EBADARG is returned. It is strongly recommended 
          that Soundstatus(10) is called to obtain supported 
          sampleformats, and select desired format accordingly!

  Return: Returns the format acutally set, or EBADARG if 
          attempting to set both signed/unsigned and/or big/little endian 
          format. If the driver does not support 24-bit samples, ENODEV 
          is returned.
          This function not exist in the AC97 driver, and so will 
          return ENODEV.

--------------------------------------------------------------------------

 Mode 11  Set desired format for 32-bit samples. This is a  
          MilanBlaster/GSXB only mode, and is is available when bits 2 
          AND 5 in _SND cookie is SET. This call is used to change the 
          format on 32-bit samples, as some hardware can support more 
          formats. It is up to the driver to allow sample formats that is 
          not supporte by hardware to be used.

  DATA:   If DATA = SND_INQUIRE (-1), the sampleformat currently in use 
          is returned. Otherwise DATA is a bitmask with the following 
          meaning;

          Bit 0 - If set, Signed
          Bit 1 - If set, Unsigned
          Bit 2 - If set, Big endian (motorola byte order)
          Bit 3 - If set, Little Endian (Intel byte order)

          From this one might think that it is possible to set both 
          Signed/Unsigned and/or Big/Little endian sampleformat. If that 
          is attempted, EBADARG is returned. It is strongly recommended 
          that Soundstatus(11) is called to obtain supported 
          sampleformats, and select desired format accordingly!

  Return: Returns the format acutally set, or EBADARG if 
          attempting to set both signed/unsigned and/or big/little endian 
          format. If the driver does not support 24-bit samples, ENODEV 
          is returned.
          This function not exist in the AC97 driver, and so will 
          return ENODEV.

--------------------------------------------------------------------------

 Modes 12-25 Gain controls. Modes 12-25 are used to set the 
             gain on individual channels. These modes are     
          MilanBlaster/GSXB, and is is available when bits 2 AND 5 in 
          _SND cookie is SET.

  DATA:   If DATA = SND_INQUIRE (-1), the current setting is returned 
          without any changes being made. Otherwise DATA is the 
          respective channels attenuation between 0 - 255. Increasing 
          gain is the same as increasing volume.

  Return: Modes 12-25 return the gain acutally set, or ENODEV if 
          the driver does not have support the given channel.
  
  NOTE: For MilanBaster it's gain, but for the original GSXB (Hades) it's
        attenuation ???. Gain seems a better choice for 14-25 because 
        it's like the ADC.

 Mode 12  Set Left Master Out gain.
 Mode 13  Set Right Master Out gain.

 Mode 14  Set Left Mic In gain.
 Mode 15  Set Right Mic In gain.
 
 Mode 16  Set Left FM Generator gain, PC Beep on AC97.
 Mode 17  Set Right FM Generator gain, 3D Control on AC97.

 Mode 18  Set Left Line In gain.
 Mode 19  Set Right Line In gain.

 Mode 20  Set Left CD In gain.
 Mode 21  Set Right CD In gain.

 Mode 22  Set Left Video/TV gain.
 Mode 23  Set Right Video/TV gain.

 Mode 24  Set Left Aux In gain.
 Mode 25  Set Right Aux In gain.

--------------------------------------------------------------------------

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************

    <<>> Setbuffer <<>> Setbuffer <<>> Setbuffer <<>> Setbuffer <<>>

  Opcode:
       XBIOS 131

  Syntax:
       long Setbuffer ( word REG, void *BEGADDR, void *ENDADDR );

  Description:
          This function is used to set the starting and ending address of 
          the DMA buffer for Playback or Capture. BEGADDR points to the 
          start of the buffer, and ENDADDR points to the first invalid 
          byte in the buffer. If a buffer starts at 0x100 and ends at 
          0x200, BEGADDR would be 0x100, and ENDADDR would be 0x201.

  REG:    This is a value indicating if this call is made to set the 
          playback buffer (DAC) or the capture (ADC) buffer.

          ReG Value    Meaning
             0       Set Playback (DAC) buffer
             1       Set Record (ADC) buffer


  NOTE:   PCM DMA buffers should always be in ST-RAM. So, in order to get 
          the correct memory type for the buffers, use Mxalloc(size, 0).

  Binding:
          pea     ENDADDR
          pea     BEGADDR
          move.w  REG,-(sp)
          move.w  #131,-(sp)
          trap    #14
          lea     12(sp),sp

  Return: Setbuffer() will return E_OK if successful, otherwise a 
          negative error code.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************

        <<>> Setmode <<>> Setmode <<>> Setmode <<>> Setmode <<>>

  Opcode:
       XBIOS 132

  Syntax:
       long Setmode( word Mode );

  Description:
          Setmode() function is used to set playback or capture mode.

  Mode:   0 - Set 8-bit  stereo playback, 16-bit stereo capture
          1 - Set 16-bit stereo playback, 16-bit stereo capture
          2 - Set 8-bit  mono playback,   16-bit stereo capture

          When bit 2 AND 5 is set in _SND cookie, the desired playback 
          mode is selected in the low byte of Mode, and the 
          desired capture mode is selected in the high byte. The playback 
          modes from above still apply.

  Mode:   3 - Set 16-bit mono playback.
          4 - Set 24-bit stereo playback, not exits on AC97 driver.
          5 - Set 32-bit stereo playback, not exits on AC97 driver.
          6 - Set 24-bit mono playback, not exits on AC97 driver.
          7 - Set 32-bit mono playback, not exits on AC97 driver.

          And this is the definition for the upperbyte, which sets the 
          capture mode;

  Mode:   0x0000 - Set 16-bit stereo capture
          0x0100 - Set 8-bit  stereo capture
          0x0200 - Set 8-bit  mono capture
          0x0300 - Set 16-bit mono capture
          0x0400 - Set 24-bit stereo capture, not exits on AC97 driver.
          0x0500 - Set 32-bit stereo capture, not exits on AC97 driver.
          0x0600 - Set 24-bit mono capture, not exits on AC97 driver.
          0x0700 - Set 32-bit mono capture, not exits on AC97 driver.

          In order to select, for example, 8-bit mono playback and 8-bit 
          mono capture, one would call Setmode( 0x0202 ).

  Binding:
          move.w  Mode,-(sp)
          move.w  #132,-(sp)
          trap    #14
          addq.l  #4,sp

  Return: Setmode() will return E_OK if selection is valid, or ENODEV if 
          the current driver does not support the desired mode. EBADR is 
          returned if a undefined Mode is attempted.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************
    <<>> Settracks <<>> Settracks <<>> Settracks <<>> Settracks <<>>

  Opcode:
      XBIOS 133

  Syntax:
      long Settracks ( word PLAYTRACKS, word RECTRACKS );

  Description:
          Settracks() is not implemented in GSXB, and will always return 
          E_OK.

  Binding:
          move.w  RECTRACKS,-(sp)
          move.w  PLAYTRACKS,-(sp)
          move.w  #133,-(sp)
          trap    #14
          addq.l  #4,sp

  Return: Always returns E_OK with GSXB.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************
   Setmontracks <<>> Setmontracks <<>> Setmontracks <<>> Setmontracks

  Opcode:
       XBIOS 134

  Syntax:
       long Setmontracks ( word MONTRACK );

  Description:
          Setmontracks() is not implemented in GSXB, and will always 
          return E_OK.

  Binding:
          move.w  MONTRACK,-(sp)
          move.w  #134,-(sp)
          trap    #14
          addq.l  #2,sp

  Return: Always returns E_OK with GSXB.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************

   Setinterrupt <<>> Setinterrupt <<>> Setinterrupt <<>> Setinterrupt

  Opcode:
      XBIOS 135

  Syntax:
      long Setinterrupt  ( word SRC_INTER, word CAUSE );
      long NSetinterrupt ( word SCR_INTER, word CAUSE, long INTH_ADDR );


  Description:
          Setinterrupt() as know by the Falcon XBIOS, because this 
          function was designed especially for him, which had the 
          "End of Frame" interrupts on Timer A or MFP's gpip 7.
          Inside the AC97 driver, it's an emulation.
          The best is to use the new NSetinterrupt().

  SRC_INTER:
          GSXB expects a parameter value = 2 for NSetinterrupt.
          This is a GSXB specific parameter, and means "install user 
          End-Of-Frame interrupt function".

  CAUSE:  These values keep the original meanings, such as;

           CAUSE value     Meaning
                0      Disable interrupt
                1      INTH_ADDR called on eof DAC interrupts
                2      INTH_ADDR called on eof ADC interrupts
                3      INTH_ADDR called on both DAC/ADC eof interrupts

  INTH_ADDR:
          This is a pointer to a small routine that is called by the 
          drivers interrupt routine on End-Of-Frame (eof) interrupts. I 
          refer to the playback/capture buffer set by Setbuffrt() as a 
          'frame' from now on. This routine is called in Supervisor mode, 
          and should end with a RTS. The driver will pass some 
          information to the function in CPU register D0. The bits in D0 
          are as follows on entry to the user interrupt function;

          Bit 0 - If cleared, playback/capture just stopped. This means 
                  that the frame is played if playback, or has been 
                  filled if capture. If set, however, it means that 
                  playback or capture just started over, either on a next 
                  frame if double buffering is being used, or just looped 
                  to the start of the frame. (A "Double Buffering" 
                  document will soon be available).

          Bit 1 - This is a loop flag. If this bit is cleared and Bit 0 
                  is set, playback/capture will stop when this frame is 
                  played through(DAC) or filled up(ADC). If set, however, 
                  playback/capture will either revert to the beginning of 
                  the frame, or swap to the second frame if double 
                  buffering is used. This flag can be changed during 
                  playback/capture using Buffoper().

          Bit 7 - This bit indicates wether it is the DAC (cleared) or 
                  ADC (set) eof that generated this interrupt. This is 
                  handy when one use the same user interrup function to 
                  handle both playback and capture eof's.(CAUSE = 3)

          The remaining bits in D0 are always cleared.

  Binding:
          pea     INTH_ADDR
          move.w  CAUSE,-(sp)
          move.w  SRC_INTER,-(sp) 
          move.w  #135,-(sp)
          trap    #14
          lea     10(sp),sp

  Return: NSetinterrup() will return E_OK if successful. If an 
          unsupported Mode is attempted, BADR is returned. If the 
          current device driver does not support user interrupts, ENODEV 
          is returned.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************
      <<>> Buffoper <<>> Buffoper <<>> Buffoper <<>> Buffoper <<>>

  Opcode:
      XBIOS 136

  Syntax:
      long Buffoper ( word Mode );

  Description:
          Buffoper() is the function used to start/stop playback or 
          capture. After setting up the necessary paramters, this 
          function is called to start the operation.

  Mode:
          If Mode = SND_INQUIRE (-1), the current operation is 
          returned. Otherwise, Mode is bitmask which selects the desired 
          operation as follows;

          Bit 0 - If set, start playback. If cleared, stop playback.
          Bit 1 - If set, enable looping for playback. If cleared, 
                  playback stops at End Of Frame.

          Bit 2 - If set, start capture. If cleared, stop capture.
          Bit 3 - If set, enable looping for capture. If cleared, capture 
                  will stops at End Of Frame.


  NOTE:   One can turn on/off looping flag for either playback/capture 
          during operation. To do that, call Buffoper(SND_INQUIRE) and 
          change only Bit 1 for playback and/or Bit 3 for capture to the 
          desired loop mode and call Buffoper() again with the new 
          setting. Calling Buffoper() with Bit 0/2 set, will not restart 
          playback/capture if already started.

  Binding:
          move.w  Mode,-(sp)
          move.w  #136,-(sp)
          trap    #14
          addq.l  #4,sp

  Return:
          Buffoper() returns E_OK if successful. Otherwise a negative 
          error code is returned.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************
<<>> Dsptristate <<>> Dsptristate <<>> Dsptristate <<>> Dsptristate <<>>

  Opcode:
      XBIOS 137

  Syntax:
      long Dsptristate ( word DSPXMIT, word DSPREC );

  Description:
          Dsptristate() is not implemented in GSXB, and will always 
          return E_OK.

  Binding:
          move.w DSPREC,-(sp)
          move.w DSPXMIT,-(sp)
          move.w #137,-(sp)
          trap   #14
          addq.l #6,sp

  Return: Dsptristate() will always return E_OK with GSXB.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************
             <<>> Gpio <<>>> Gpio <<>> Gpio <<>> Gpio <<>>

  Opcode:
      XBIOS 138

  Syntax:
      long Gpio ( word Mode, word DATA );

  Description:
          Gpio() is used to read the gpio pins of the DSP's connector. 

  Mode:   Mode selects what operation to do as follows;

          Mode     Meaning of DATA
           0       Set bits in DATA will make the corresponding gpio bit 
                   output.
           1       Read gpio status, DATA is ignored.
                   For Devconnect usage with CD clocks:
                   bit0: 0: external clock 22.5792 Mhz for 44.1KHz.
                         1: clock 24.576 MHz for 48KHZ.
		   bit1: return 1 for quartz
           2       Write to gpio as given in DATA.
                   For Devconnect usage with CD clocks:
                   bit0: 0: external clock 22.5792 Mhz for 44.1KHz.
                         1: clock 24.576 MHz for 48KHZ.

  Binding:
  	       move.w  DATA,-(sp)
  	       move.w  Mode,-(sp)
  	       move.w  #138,-(sp)
  	       trap    #14
  	       addq    #6,sp

  Return: Gpio() will return a E_OK if successful, except when Mode 1, in 
          which case the read read gpio bits are returned. If the driver 
          doesnt support a given Mode it returns ENODEV. If the driver 
          doesn't have support for gpio access at all, ENOSYS is returned.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************
  <<>> Devconnect <<>> Devconnect <<>> Devconnect <<>> Devconnect <<>>

  Opcode:
      XBIOS 139

  Syntax:
      long Devconnect ( word SRC, word DST, word CLK, word PRESCALE, word 
                        PROT );

  Description:
          Devconnect() implementation in GSXB is limited at this time. 
          This is because most soundcards don't have a multiplexer that 
          resembles the one in the Falcon. At this time, SRC and DST is 
          ignored, only PRESCALE and CLK is used. This is because there 
          is no GSXB <-> driver interface to handle hardware that might 
          have something similar to the Falcon multiplexer. Also, no 
          GSXB <-> driver interface for DSP handling is present... yet. 
          Hope to obtain some DSP hardware and docs to implement this in 
          the future, tho.

          Deconnect() attatches a source device in the sound system to 
          one or multiple destination devices through the use of the 
          connection matrix. (Falcon only, not GSXB supported .. yet)


 SRC:     SRC selects the source device to  connect as follows;

          Name    Source  Meaning

          DMAPLAY   0     DMA playback
          DSPXMIT   1     DSP Transmit
          EXTINP    2     External Input
          ADC       3     Microphone/Yamaha

 DST:     DST is a bitmask indicating which device(s) will get input from 
          SRC as follows;

          Name     Mask   Meaning

          DMAREC   0x01   DMA Capture
          DSPRECV  0x02   DSP Receive
          EXTOUT   0x04   External Out
          DAC      0x08   DAC

  CLK:    CLK is the clock the source device will use.

          Name    CLK   Meaning
          CLK_25M  0     Internal 25.175 Mhz clock.
          CLK_EXT  1     External clock (22.5792 or 24.576 Mhz, see Gpio).
          CLK_32M  2     Internal 32 Mhz clock.

  PRESCALE:
          PRESCALE chooses the SRC clock prescaler. Sample rate is 
          determined as follows;

                               clockrate/256
                  samplerate = -------------
                                prescale - 1

          When PRESCALE has a value of CLK_COMPAT (0), the value set by 
          Soundcmd(SETPRESCALE) is used to set the desired sample rate. 
          (See Soundcmd()). Here is a table of PRESCALE values and 
          resulting sample rates when CLK = 0 (internal 25.175 Mhz clock).

          Name       Prescale  Meaning

          CLK_COMPAT     0     TT030/STe compatibility mode. Use 
                               prescale value set by Soundcmd(SETPRESCALE)
                               CLK_25M     CLK_EXT     CLK_EXT
                              25.175 Mhz 22.5792 Mhz  24.576 Mhz
          CLK_50K        1     49170 Hz    44100 Hz    48000 Hz
          CLK_33K        2     33800 Hz    29400 Hz    32000 Hz
          CLK_25K        3     24585 Hz    22050 Hz    24000 Hz
          CLK_20K        4     20770 Hz    17640 Hz    19200 Hz
          CLK_16K        5     16940 Hz    14700 Hz    16000 Hz
          CLK_12K        7     12292 Hz    11025 Hz    12000 Hz
          CLK_10K        8      9834 Hz     8820 Hz     9600 Hz
          CLK_8K        11      8195 Hz     7350 Hz     8000 Hz
          
  PROT:   PROT sets the handshaking mode for DSP<->Codec transfers, and 
          is ignored by GSXB at this time. A value of 0 enables 
          handshaking, a value of 1 disables it.

  NOTE:   The sample rate is set for both DAC/ADC by Devconnect().

  Binding:
          move.w PROT,-(sp)
          move.w PRESCALE,-(sp)
          move.w CLK,-(sp)
          move.w DST,-(sp)
          move.w SRC,-(sp)
          move.w #139,-(sp)
          trap   #14
          lea    12(sp),sp


  Return: Devconnect() always returns E_OK with GSXB at this time.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************
    <<>> Sndstatus <<>> Sndstatus <<>> Sndstatus <<>> Sndstatus <<>>

  Opcode:
      XBIOS 140

  Syntax:
      long Sndstatus ( word Mode );

  Description:
          Sndstatus() is originally used to either reset the sound system 
          or get some status information about it. GSXB adds a lot to 
          this function. Audio application authors are strongly adviced 
          to use use this Sndstatus() to obtain information about the 
          currenlty installed driver, such as sample formats, etc.


  Mode:
          Mode   Meaning

            0    Originally this mode (called reset elsewhere) returned 
                 information about the soundsystem. GSXB always return 0 
                 when this Mode is used.

            1    This mode should reset the soundsystem.

          If both bits 2 AND bit 5 in _SND cookie is set, these 
          additional modes are awailable, under both GSXB and 
          MilanBlaster.

            2    Query supported sample resolutions. This will return a 
                 bitmask of available sample resolutions the current 
                 driver supports. The meaning of the bitmask is defined 
                 as follows - a SET bit means the corresponding 
                 resolution is supported;

                 Bit 0 - 8-bit  samples supported
                 Bit 1 - 16-bit samples supported
                 Bit 2 - 24-bit samples supported
                 Bit 3 - 32-bit samples supported

            3    Query available mixer lines. This mode will return a 
                 bitmask of available Mixer elements, or attenuation/gain 
                 controls. A SET bit means the element is available;

                 Bit 0 - Record Gain (ADC)
                 Bit 1 - PCM attenuation (DAC)
                 Bit 2 - Mic attenuation
                 Bit 3 - FM Generator attenuation, PC Beep / 3D Control on AC97
                 Bit 4 - Line In attenuation
                 Bit 5 - CD In attenuation
                 Bit 6 - Video/TV In attenuation
                 Bit 7 - Aux attenuation

            4    Query available record sources. This mode will return a 
                 bitmask of available record sources. A SET bit means the 
                 source is available as a record source.

                 Bit 0  - Mic Right
                 Bit 1  - Mic Left
                 Bit 2  - FM Generator Right, not used on AC97
                 Bit 3  - FM Generator Left, not used on AC97
                 Bit 4  - Line In Right
                 Bit 5  - Line In Left
                 Bit 6  - CD In Right
                 Bit 7  - CD In Left
                 Bit 8  - Video/TV In Right
                 Bit 9  - Video/TV In Left
                 Bit 10 - Aux In Right
                 Bit 11 - Aux In Left
                 Bit 12 - Master mix Right
                 Bit 13 - Master mix Left

            5    Query duplex capability. Use this Mode to determine 
                 whether or not the current driver (and hardware) 
                 supports full duplex or not. Currently only one bit is 
                 defined in the return by this mode, as follows;

                 Bit 0 - 1 = Supports full duplex, 0 = Does not support 
                             full duplex.


            8    Query 8-bit sample formats supported. This mode will 
                 return a bitmask of currently supported 8-bit sample 
                 formats. A SET bit means that the format is supported in 
                 hardware, as follows;

                 Bit 0 - Signed
                 Bit 1 - Unsigned

                 If the current driver/hardware does not support 8-bit 
                 samples, this mode will return ENODEV.

            9    Query 16-bit sample formats supported. This mode will 
                 return a bitmask of currently supported 16-bit sample 
                 formats. A SET bit means that the format is supported in 
                 hardware, as follows;

                 Bit 0 - Signed
                 Bit 1 - Unsigned
                 Bit 2 - Big endian (Motorola byte order)
                 Bit 3 - Little endian (Intel byte order)

                 If the current driver/hardware does not support 16-bit 
                 sample-resolution, this mode will return ENODEV.

            10   Query 24-bit sample formats supported. This mode will 
                 return a bitmask of currently supported 24-bit sample 
                 formats. A SET bit means that the format is supported in 
                 hardware, as follows;

                 Bit 0 - Signed
                 Bit 1 - Unsigned
                 Bit 2 - Big endian (Motorola byte order)
                 Bit 3 - Little endian (Intel byte order)

                 If the current driver/hardware does not support 24-bit 
                 sample-resolution, this mode will return ENODEV.

            11   Query 32-bit sample formats supported. This mode will 
                 return a bitmask of currently supported 32-bit sample 
                 formats. A SET bit means that the format is supported in 
                 hardware, as follows;

                 Bit 0 - Signed
                 Bit 1 - Unsigned
                 Bit 2 - Big endian (Motorola byte order)
                 Bit 3 - Little endian (Intel byte order)

                 If the current driver/hardware does not support 32-bit 
                 sample-resolution, this mode will return ENODEV.

  Binding:
          move.w Mode,-(sp)
          move.w #140,-(sp)
          trap   #14
          addq.l #4,sp
          
  Return: The return by Sndstatus depends on the Mode used.
  
*************************************************************************
-------------------------------------------------------------------------
*************************************************************************
        <<>> Buffptr <<>> Buffptr <<>> Buffptr <<>> Buffptr <<>>

  Opcode:
      XBIOS 141

  Syntax:
      long Buffptr ( long *PTR );

  Description:
          Buffptr() returns the current position of the playback and 
          capture pointers.

  PTR:    PTR is a pointer to a structure that is filled in with the 
          current position of the Playback (DAC) and capture (ADC) 
          pointers. The structure looks like this;

          typedef struct
          {
          void *playback_pos
          void *capture_pos
          long reserved1
          long reserved2
          } SBUFPTR;

  Binding:
          pea	  PTR
          move.w  #141,-(sp)
          trap    #14
          addq.l  #6,sp

  Return: Buffptr() returns E_OK if successful, otherwise a negative 
          error code is returned.

*************************************************************************
-------------------------------------------------------------------------
*************************************************************************
