/* ------------------------ System includes ------------------------------- */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define atol _atol
#define atof _atof
#include "m68k_disasm.h"

/* ------------------------ FreeRTOS includes ----------------------------- */
#include "../freertos/FreeRTOS.h"
#include "../freertos/task.h"
#include "../freertos/queue.h"

/* ------------------------ Project includes ------------------------------ */
#include "config.h"
#include "../../include/version.h"
#include "../../include/fire.h"
#undef __MBAR
#include "net.h"
#ifdef MCF5445X
#include "flash.h"
#else
#ifdef MCF547X
#include "amd_flash.h"
#else /* MCF548X */
#include "intel_c3_flash.h"
#endif /* MCF547X */
#endif /* MCF5445X */
#include "get.h"
#include "gif.h"

/* ------------------------ lwIP includes --------------------------------- */
#include "sockets.h"
#include "tcp.h"

/* ------------------------ BDOS includes ----------------------------------*/
/* cannot use TOS trap out of CF68KLIB !!! */
#include "../bdos/bdos.h"
/* hope than the TOS update this variables ! */
#define Tgetdate() *(unsigned short *)0x1176
#define Tgettime() *(unsigned short *)0x1178

#ifdef LWIP

/* ------------------------ Defines --------------------------------------- */
/* Connection socket */
#define TIMEOUT                 2 /* sec */
#define READBUF_SIZE            6400
#define WRITEBUF_SIZE           32000
#define SOCK_BUF_SIZE           32000
#define TASKS_SERVER            5

#define BUF_SIZE 1024
#define MAX_LENGTH 1000

#define VERSION_WEB 0x0100

/* The port on which we listen. */
#define webHTTP_PORT            80

/* the http versions we support */
enum http_version {VERSION_UNKNOWN, VERSION_10, VERSION_11};

#define SIZE_TOS_FLASH      0x00100000 // last 65KB for TOS parameters

static int Flash, Error;
static unsigned char rec_len;  /* longueur S-record  */
static unsigned char CS;       /* checksum */
static char sbuf[256];
static char *sbuf_ptr;
static unsigned long lowest_address, hight_address, Mem_Data;

typedef struct sock_msg_struct
{
  int sock;
  int reserved[3];
} sock_msg;

typedef struct sock_conn_struct
{
  int sock;
  int errno;
  int version;
  int content_length;
  char boundary[256];
  char *response;
  int response_size;
  int response_max_size;
  char *buf_write;
  int offset_buf_write;
} sock_conn;

typedef struct http_list_struct
{
  const char *method;
  const char *url;
  void (*handle_url)(sock_conn *conn, char *request);
  const char *content_type;
} http_list;

typedef struct http_status_struct
{
  int code;
  const char *text;
} http_status;

extern int errno;
extern void conout_debug(int c);
extern void conws_debug(char *buf);

static char *types1[] = { "HEXA", "BIT", "BYTE", "SHORT", "LONG", "FLOAT", "DOUBLE", NULL };
static char *types2[] = { "BYTE", "SHORT", "LONG", "FLOAT", "DOUBLE", NULL };

static unsigned char red_led_gif[] = {
71,73,70,56,57,97,10,0,10,0,230,0,0,248,132,129,171,51,23,187,46,22,240,36,31,
247,115,112,245,81,80,245,85,84,241,38,34,204,39,21,215,34,19,226,31,19,246,104,
102,200,73,43,213,34,19,246,107,102,244,68,68,247,116,112,248,138,135,221,65,40,
248,143,136,197,72,42,228,187,149,243,51,50,229,232,219,236,26,18,191,44,22,228,
29,19,197,160,125,215,222,209,182,47,23,205,206,186,248,182,159,167,54,24,197,
41,21,209,165,130,233,241,238,239,232,193,246,109,106,231,27,18,247,123,119,238,
30,24,210,35,20,226,30,19,199,40,21,193,43,21,246,181,161,243,49,48,244,72,72,
178,49,23,243,57,57,238,200,169,210,203,175,217,34,20,214,68,40,239,240,228,244,
63,63,238,209,173,235,240,224,221,206,174,238,245,234,247,250,250,191,172,140,
249,160,149,177,50,23,232,27,18,195,42,21,195,159,121,238,29,22,250,166,152,241,
40,37,200,205,186,243,56,55,248,134,131,248,149,142,248,176,157,241,193,167,190,
157,121,227,233,222,241,41,39,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,33,249,4,0,0,0,0,0,44,0,0,0,0,10,0,10,0,0,7,98,128,79,79,60,
54,50,31,56,57,130,79,59,75,45,62,72,4,5,58,79,35,74,68,73,0,16,6,49,7,23,36,17,
0,39,37,5,71,7,24,34,19,4,11,6,15,46,3,64,9,18,14,47,55,22,69,40,42,41,33,53,21,
78,3,67,26,52,8,25,29,66,77,38,10,13,8,65,2,63,1,30,79,51,43,44,2,48,1,32,61,138,
28,27,12,20,76,70,130,129,0,59,
};

static unsigned char green_led_gif[] = {
71,73,70,56,57,97,10,0,10,0,230,78,0,0,143,13,0,148,14,0,134,13,0,190,18,0,224,
21,37,255,58,0,155,14,2,226,23,19,243,40,0,173,16,165,244,186,38,225,59,0,169,
16,0,132,12,85,252,106,0,200,19,0,153,14,0,193,18,0,179,17,20,244,41,111,182,127,
0,215,20,0,180,17,0,159,15,98,180,114,208,237,229,14,238,35,206,237,226,0,176,
16,154,202,171,38,160,54,63,255,84,0,202,19,0,161,15,0,170,16,98,176,113,75,255,
96,124,246,144,183,225,202,0,211,20,0,162,15,0,138,13,0,168,16,0,207,19,0,219,
21,0,139,13,38,150,52,0,191,18,130,223,150,0,147,14,38,167,54,12,236,33,38,152,
53,0,186,17,62,244,83,27,251,48,101,252,122,52,255,73,182,235,202,167,220,186,
191,240,211,0,187,18,98,195,115,147,244,168,40,255,61,150,201,168,0,206,19,44,
255,65,134,204,152,98,181,114,0,150,14,0,163,15,112,217,131,86,255,107,0,141,13,
70,255,91,59,255,80,170,213,188,223,235,243,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,33,249,4,1,0,0,78,0,44,0,0,0,0,10,0,10,0,64,7,98,128,
78,78,25,10,56,14,37,58,130,78,68,16,1,0,45,2,13,20,78,54,8,51,7,21,15,53,9,40,
50,27,75,31,57,5,19,7,43,3,59,72,17,61,18,34,71,6,49,74,24,78,60,73,36,76,64,8,
4,48,78,63,67,5,55,26,4,66,3,28,62,11,44,39,32,47,22,12,23,70,30,38,9,42,33,6,
142,41,2,65,130,77,69,52,46,35,29,130,129,0,59,
};

static xQueueHandle mbox; 

extern int Flash, Error;
extern char sbuf[256];
extern char *sbuf_ptr;
extern unsigned long lowest_address, hight_address, Mem_Data;

static http_status m_http_status10[] = {
  { 200, "HTTP/1.0 200 OK\r\n" },
  { 201, "HTTP/1.0 201 Created\r\n" },
  { 202, "HTTP/1.0 202 Accepted\r\n" },
  { 204, "HTTP/1.0 204 No Content\r\n" },
  { 205, "HTTP/1.0 205 Reset Content\r\n" },
  { 206, "HTTP/1.0 206 Partial Content\r\n" },
  { 301, "HTTP/1.0 301 Moved Permanently\r\n" },
  { 302, "HTTP/1.0 302 Found\r\n" },
  { 304, "HTTP/1.0 304 Not Modified\r\n" },
  { 400, "HTTP/1.0 400 Bad Request\r\n" },
  { 401, "HTTP/1.0 401 Unauthorized\r\n" },
  { 403, "HTTP/1.0 403 Forbidden\r\n" },
  { 404, "HTTP/1.0 404 Not Found\r\n" },
  { 500, "HTTP/1.0 500 Internal Server Error\r\n" },
  { 501, "HTTP/1.0 501 Not Implemented\r\n" },
  { 502, "HTTP/1.0 502 Bad Gateway\r\n" },
  { 503, "HTTP/1.0 503 Service Unavailable\r\n" },
};

static http_status m_http_status11[] = {
  { 100, "HTTP/1.1 100 Continue\r\n" },
  { 101, "HTTP/1.1 101 Switching Protocols\r\n" },
  { 200, "HTTP/1.1 200 OK\r\n" },
  { 201, "HTTP/1.1 201 Created\r\n" },
  { 202, "HTTP/1.1 202 Accepted\r\n" },
  { 203, "HTTP/1.1 203 Non-Authorative Information\r\n" },
  { 204, "HTTP/1.1 204 No Content\r\n" },
  { 205, "HTTP/1.1 205 Reset Content\r\n" },
  { 206, "HTTP/1.1 206 Partial Content\r\n" },
  { 300, "HTTP/1.1 300 Multiple Choices\r\n" },
  { 301, "HTTP/1.1 301 Moved Permanently\r\n" },
  { 302, "HTTP/1.1 302 Found\r\n" },
  { 303, "HTTP/1.1 303 See Other\r\n" },
  { 304, "HTTP/1.1 304 Not Modified\r\n" },
  { 305, "HTTP/1.1 305 Use Proxy\r\n" },
  { 307, "HTTP/1.1 307 Temporary Redirect\r\n" },
  { 400, "HTTP/1.1 400 Bad Request\r\n" },
  { 401, "HTTP/1.1 401 Unauthorized\r\n" },
  { 402, "HTTP/1.1 402 Payment Required\r\n" },
  { 403, "HTTP/1.1 403 Forbidden\r\n" },
  { 404, "HTTP/1.1 404 Not Found\r\n" },
  { 405, "HTTP/1.1 405 Method Not Allowed\r\n" },
  { 406, "HTTP/1.1 406 Not Acceptable\r\n" },
  { 407, "HTTP/1.1 407 Proxy Authentication Required\r\n" },
  { 408, "HTTP/1.1 408 Request Time-out\r\n" },
  { 409, "HTTP/1.1 409 Conflict\r\n" },
  { 410, "HTTP/1.1 410 Gone\r\n" },
  { 411, "HTTP/1.1 411 Length Required\r\n" },
  { 412, "HTTP/1.1 412 Precondition Failed\r\n" },
  { 413, "HTTP/1.1 413 Request Entity Too Large\r\n" },
  { 414, "HTTP/1.1 414 Request-URI Too Large\r\n" },
  { 415, "HTTP/1.1 415 Unsupported Media Type\r\n" },
  { 416, "HTTP/1.1 416 Requested range not satisfiable\r\n" },
  { 417, "HTTP/1.1 417 Expectation Failed\r\n" },
  { 500, "HTTP/1.1 500 Internal Server Error\r\n" },
  { 501, "HTTP/1.1 501 Not Implemented\r\n" },
  { 502, "HTTP/1.1 502 Bad Gateway\r\n" },
  { 503, "HTTP/1.1 503 Service Unavailable\r\n" },
  { 504, "HTTP/1.1 504 Gateway time-out\r\n" },
  { 505, "HTTP/1.1 505 HTTP Version not supported\r\n" },
};

static void ltoa(char *buf, long n, unsigned long base)
{
  unsigned long un;
  char *tmp, ch;
  un = n;
  if((base == 10) && (n < 0))
  {
    *buf++ = '-';
    un = -n;
  }
  tmp = buf;
  do
  {
    ch = un % base;
    un = un / base;
    if(ch <= 9)
      ch += '0';
    else
      ch += 'a' - 10;
    *tmp++ = ch;
  }
  while(un);
  *tmp = '\0';
  while(tmp > buf)
  {
    ch = *buf;
    *buf++ = *--tmp;
    *tmp = ch;
  }
}

typedef union
{ 
  long L; 
  float F; 
}  LF_t; 

static void ftoa(float f, int max, char *buf) 
{ 
  long mantissa, int_part, frac_part; 
  short exp2; 
  LF_t x; 
  x.F = f; 
  if(x.L == 0) 
  { 
    *buf++ = '0'; 
    *buf++ = '\0';
    return; 
  } 
  exp2 = (unsigned char)(x.L >> 23) - 127; 
  mantissa = (x.L & 0xFFFFFF) | 0x800000; 
  frac_part = 0; 
  int_part = 0; 
  if((exp2 >= 31) || (exp2 < -23))
  { 
    *buf++ = 'n'; 
    *buf++ = 'a'; 
    *buf++ = 'n'; 
    *buf++ = '\0';
    return;
  } 
  else if(exp2 >= 23) 
    int_part = mantissa << (exp2 - 23); 
  else if(exp2 >= 0) 
  { 
    int_part = mantissa >> (23 - exp2); 
    frac_part = (mantissa << (exp2 + 1)) & 0xFFFFFF; 
  } 
  else
    frac_part = (mantissa & 0xFFFFFF) >> -(exp2 + 1); 
  if(x.L < 0) 
    *buf++ = '-'; 
  if(int_part == 0) 
    *buf++ = '0'; 
  else 
  { 
    ltoa(buf, int_part, 10); 
    while(*buf) 
      buf++; 
  } 
  if((frac_part != 0) && (max != 0)) 
  { 
    char m; 
    *buf++ = '.'; 
    for(m = 0; m < max; m++) 
    { 
      frac_part = (frac_part << 3) + (frac_part << 1); 
      *buf++ = (frac_part >> 24) + '0'; 
      frac_part &= 0xFFFFFF; 
    } 
    for(--buf; buf[0] == '0' && buf[-1] != '.'; --buf); 
      ++buf; 
  } 
  *buf = '\0'; 
} 

static long numeric(long ch)
{
  if((ch >= '0') && (ch <= '9'))
    return(1);
  return(0);
}

static int isspace(int c)
{
  switch(c)
  {
    case ' ':
    case '\f':
    case '\n':
    case '\r':
    case '\t':
    case '\v':
      return(1);
  }
  return(0);
}

static long check_base(char ch, long base)
{
  if(numeric(ch) && (ch < '0' + base))
    return(ch - '0');
  if((ch >= 'a') && (ch <= 'z'))
    ch -= ('a' - 'A');
  if((ch >= 'A') && (ch < 'A' + base - 10))
    return(ch - 'A' + 10);
  return(-1);
}

static long atol(const char *text)
{
  long n;
  int minus, base, ch;
  while(isspace(*text))
    text++;
  minus = 0;   
  if(*text == '-')
  {
    minus = 1;
    text++;
  }
  base = 10;
  if(*text == '$')
  {
    base = 16;
    text++;
  }
  else if(*text == '%')
  {
    base = 2;
    text++;
  }
  n = 0;
  while((ch = check_base(*text++, base)) >= 0)
    n = n * base + ch;
  if(minus)
    n = -n;
  return(n);
}

static float atof(const char *text)
{
  long n;
  float nf;
  int minus, base, ch;
  while(isspace(*text))
    text++;
  minus = 0;   
  if(*text == '-')
  {
    minus = 1;
    text++;
  }
  base = 10;
  if(*text == '$')
  {
    base = 16;
    text++;
  }
  else if(*text == '%')
  {
    base = 2;
    text++;
  }
  n = 0;
  while((ch = check_base(*text++, base)) >= 0)
    n = n * base + ch;
  nf = (float)n;
  if(text[-1] == '.')
  {
    n = base;
    while((ch = check_base(*text++, base)) >= 0)
    {
      nf += (float)ch/(float)n;
      n *= base;
    }
  }  
  if(minus)
    nf = -nf;
  return(nf);
}

static void minus(char *s)
{
  while(*s)
  {
    if(*s>='A' && *s<='Z')
      *s += 0x20;
    if(*s=='\\')
      *s='/';
    s++;
  }
}

static int read_socket(sock_conn *conn, char *request, int size, int *size_header)
{
  int i, n = 0, len = 0;
  fd_set data_read;
  struct timeval tv;
  char *ptr = request, *ptr2;
  if(size_header != NULL)  
    *size_header = 0;
  if(conn->errno)
    return(-1);
  do
  {
    FD_ZERO(&data_read);
    FD_SET(conn->sock, &data_read); 
    tv.tv_sec = TIMEOUT;
    tv.tv_usec = 0;
    i = select(FD_SETSIZE, &data_read, NULL, NULL, &tv);
    if((i > 0) && (FD_ISSET(conn->sock, &data_read) != 0))
    {
      n = recv(conn->sock, ptr, size - len, 0);
      if(n >= 0)
      {
        len += n;
        ptr += n;
        *ptr = 0;
        if((size_header != NULL)
         && ((ptr2 = strstr(request, "\r\n\r\n")) != NULL))
        {
          *size_header = (int)(ptr2 - request) + 4;
          break;
        }
      }
      else
        conn->errno = errno;
    }
  }
  while((n >= 0) && (n < size) && (i > 0));
  return((n < 0) ? n : len);
}

static int write_socket(sock_conn *conn, char *response, int size, int flush)
{
  int i, n = 0, len;
  fd_set data_write;
  struct timeval tv;
  char *ptr = response;
  if((conn->buf_write == NULL) || (response == NULL) || conn->errno)
    return(-1);
  do
  {
    len = WRITEBUF_SIZE - conn->offset_buf_write;
    if(size < len)
      len = size;
    if(len >= 0)
    {
      memcpy(&conn->buf_write[conn->offset_buf_write], response, len);
      size -= len;
      conn->offset_buf_write += len;
      response += len;  
    }
    if((conn->offset_buf_write >= WRITEBUF_SIZE)
     || ((size <= 0) && flush))
    {
      len = n = 0;
      ptr = conn->buf_write;
      do
      {
        FD_ZERO(&data_write);
        FD_SET(conn->sock, &data_write);
        tv.tv_sec = TIMEOUT;
        tv.tv_usec = 0;
        i = select(FD_SETSIZE, NULL, &data_write, NULL, &tv);
        if((i > 0) && (FD_ISSET(conn->sock, &data_write) != 0))
        {
          n = send(conn->sock, ptr, conn->offset_buf_write - len, 0);
          if(n >= 0)
          {
            ptr += n;
            len += n;
          }
          else
            conn->errno = errno;
        }
      }
      while((n >= 0) && (len < conn->offset_buf_write) && (i > 0));
      conn->offset_buf_write = 0;
    }
  }
  while(size > 0);
  return(n < 0 ? n : len);
}

static void write_string(sock_conn *conn, char *text)
{
  write_socket(conn, text, strlen(text), 0);
}

static int send_status_code(sock_conn *conn, int status_code)
{
  int i;
  if(conn->version == VERSION_10)
  {
    for(i = 0; i < sizeof(m_http_status10)/sizeof(m_http_status10[0]); i++)
    {
      if(m_http_status10[i].code == status_code)
      {
        write_socket(conn, (char *)m_http_status10[i].text, strlen((void *)m_http_status10[i].text), status_code == 200 ? 0 : 1);
        return 1;
      }
    }
  }
  else
  {
    for(i = 0; i < sizeof(m_http_status11)/sizeof(m_http_status11[0]); i++)
    {
      if(m_http_status11[i].code == status_code)
      {
        write_socket(conn, (char *)m_http_status11[i].text, strlen((void *)m_http_status11[i].text), status_code == 200 ? 0 : 1);
        return 1;
      }
    }
  }
  /* Unsupported status code? Pretty internal error, isn't it? Send 500 */
  send_status_code(conn, 500);
  return 0;
}

static void send_content_type(sock_conn *conn, const char *content_type)
{
  char buf[64];
  strcpy(buf,  "Content-Type: ");
  strcat(buf, content_type);
  strcat(buf, "\r\n");
  write_string(conn, buf);
}

static int dayofweek(int year,int mon,int mday)
{
  static int doylookup[2][13] = {
   { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
   { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }};
  int doe,isleapyear;
  int era,cent,quad,rest;
  /* break down the year into 400, 100, 4, and 1 year multiples */
  rest = year-1;
  quad = rest/4;
  rest %= 4;
  cent = quad/25;
  quad %= 25;
  era = cent/4;
  cent %= 4;
  /* leap year every 4th year, except every 100th year,
     not including every 400th year. */
  isleapyear = !(year % 4) && ((year % 100) || !(year % 400));
  /* set up doe */
  doe = mday + doylookup[isleapyear][mon - 1];
  doe += era * (400 * 365 + 97);
  doe += cent * (100 * 365 + 24);
  doe += quad * (4 * 365 + 1);
  doe += rest * 365;
  return(doe %7);
}

static unsigned long gettime(void)
{
  return(((unsigned long)Tgetdate() << 16) + ((unsigned long)Tgettime() & 0xffff));
}

static void send_date(sock_conn *conn, const char *name, unsigned long datetime)
{
  static char *days[] = { "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" };
  static char *months[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
  char buf[64], buf2[10];
  int year, mon, mday;
  year = (int)((datetime >> 25) + 1980UL);      /* year */
  mon = (int)((datetime >> 21) & 0xf);          /* month */
  if(mon < 1)
  	mon = 1;
  mday = (int)((datetime >> 16) & 0x1f);        /* day of month */
  strcpy(buf, name);
  strcat(buf, days[dayofweek(year,mon,mday)]);
  strcat(buf, ", ");
  ltoa(buf2, mday + 100, 10);
  strcat(buf, &buf2[1]);
  strcat(buf, " ");
  strcat(buf, months[mon-1]);
  strcat(buf, " ");
  ltoa(buf2, year, 10);
  strcat(buf, buf2);
  strcat(buf, " ");
  ltoa(buf2, ((datetime >> 11) & 0x1f) + 100, 10); /* hour */
  strcat(buf, &buf2[1]);
  strcat(buf, ":");
  ltoa(buf2, ((datetime >> 5) & 0x3f) + 100, 10);  /* mn */
  strcat(buf, &buf2[1]);
  strcat(buf, ":");
  ltoa(buf2, ((datetime & 0x1f) << 1) + 100, 10);  /* sec */
  strcat(buf, &buf2[1]);
  strcat(buf, " GMT\r\n");  
  write_string(conn, buf);
}

static void send_content_length(sock_conn *conn, int length)
{
  char buf[64], buf2[10];
  strcpy(buf,  "Content-Length: ");
  ltoa(buf2, length, 10);
  strcat(buf, buf2);
  strcat(buf, "\r\n");
  write_string(conn, buf);
}

static int copy_file(char *path, char *buf, long size)
{
  long file;
  char *p = path;
  while(*path)
  {
    if((*path == '\\') || (*path == '/'))
      p = path+1;  
    path++;
  }
  if((file = Fcreate(p, 0)) >= 0)
  {
    if(size)
      Fwrite(file, size, buf);
    Fclose(file);
    return(0);
  }
  return(-1);
}

#ifdef MCF5445X

static int Programmation(unsigned long int begin, unsigned long int end, unsigned long int mem)
{
  if((begin < FLASH_TOS_FIRE_ENGINE) || (begin >= FLASH_TOS_FIRE_ENGINE+SIZE_TOS_FLASH))
    return(-1);
  if((end < FLASH_TOS_FIRE_ENGINE) || (end >= FLASH_TOS_FIRE_ENGINE+SIZE_TOS_FLASH))
    return(-1);  
  UnprotectCSBOOT();
  FlashIdentify();
  UnlockFlashBlockAll();
  if(EraseFlash(begin, end) != SUCCESS)
  {
    ResetFlash();
    ProtectCSBOOT();
    return(-1);
  }
  else
  {
    unsigned long *p =(unsigned long *)mem; 
    for(; begin < end; begin += 4)
    {
      if(ProgFlash(begin, *p++) != SUCCESS)
      {
        ResetFlash();
        ProtectCSBOOT();
        return(-1);
      }
    }
  }
  ResetFlash();
  ProtectCSBOOT();
  return(0);
}

#else

#ifdef MCF547X

static int Programmation(unsigned long int begin, unsigned long int end, unsigned long int mem)
{
  if((begin < FLASH_TOS_FIRE_ENGINE) || (begin >= FLASH_TOS_FIRE_ENGINE+SIZE_TOS_FLASH))
    return(-1);
  if((end < FLASH_TOS_FIRE_ENGINE) || (end >= FLASH_TOS_FIRE_ENGINE+SIZE_TOS_FLASH))
    return(-1);  
  UnprotectCSBOOT();
  if(FlashIdentify() != SUCCESS)
  {
    ProtectCSBOOT();
    return(-1);
  }
  if(EraseFlash(begin, end) != SUCCESS)
  {
    ProtectCSBOOT();
    return(-1);
  }
  else
  {
    if(ProgFlash(begin, end, (void *)mem) != SUCCESS)
    {
      ProtectCSBOOT();
      return(-1);
    }
  }
  ProtectCSBOOT();
  return(0);
}

#else /* MCF548X */

static int Programmation(unsigned long int begin, unsigned long int end, unsigned long int mem)
{
  int bytes = (int)(end-begin);
  if((begin < FLASH_TOS_FIRE_ENGINE) || (begin >= FLASH_TOS_FIRE_ENGINE+SIZE_TOS_FLASH))
    return(-1);
  if((end < FLASH_TOS_FIRE_ENGINE) || (end >= FLASH_TOS_FIRE_ENGINE+SIZE_TOS_FLASH))
    return(-1);  
  if(begin >= end)
    return(-1);
  if(begin & INTEL_C3_FLASH_CELL_MASK)
    return(-1);
  bytes += INTEL_C3_FLASH_CELL_MASK;
  bytes &= ~INTEL_C3_FLASH_CELL_MASK;
  intel_c3_flash_init(BOOT_FLASH_BASE);
  if(intel_c3_flash_program(begin, mem, bytes, 1, NULL, NULL) != bytes)
    return(-1);
  return(0);  
}

#endif /* MCF547X */
#endif /* MCF5445X */

/***********************************************************************/
/* getbh: Read 2 ASCII characters from the S-record buffer and         */
/*        convert them into their corresponding binary value           */
/*                                                                     */
/*  INPUT: None                                                        */
/* OUTPUT: value:    Binary value of byte pair                         */
/*         sbuf_ptr: Incremented by 2                                  */
/*                                                                     */
/***********************************************************************/
static unsigned char getbh(void)
{
  unsigned long c, i, value = 0;
  for(i = 0; i < 2; i++)
  {
    c = *sbuf_ptr++;
    value <<= 4;
    value  += c;
    if((c >= '0') && (c <= '9'))
      value -= '0';
    else
    {
      if((c >= 'A') && (c <= 'F'))
        value -= ('A' - 10);
      else
      {
        Error=1;
        return(0);
      }
    }
  }
  return value;
}

/***********************************************************************/
/* getcsbh: Read a byte pair from the record buffer, updating          */
/*          the calculated checksum and remaining record length        */
/*                                                                     */
/*  INPUT: None                                                        */
/* OUTPUT: val: Binary value of byte pair                              */
/*                                                                     */
/***********************************************************************/
static unsigned char getcsbh(void)
{
  unsigned char val;
  CS += (val = getbh());
  return val;
}

/***********************************************************************/
/* read_rec: Read an S-record from the S-record buffer and write       */
/*           the data it represents to memory                          */
/*                                                                     */
/*  INPUT: None                                                        */
/* OUTPUT: None                                                        */
/*                                                                     */
/***********************************************************************/
static void read_rec(void)
{
  unsigned long rec_type, addr, i;
  unsigned char data;
  int bypass_data;
  /*---------------------------------------------------------------------*/
  /* Position sbuf_ptr to just after 'S' of S-record.                    */
  /*---------------------------------------------------------------------*/
  for(sbuf_ptr = sbuf; *sbuf_ptr != 'S';)
  if(!(*++sbuf_ptr))
    return;
  sbuf_ptr++;
  /*---------------------------------------------------------------------*/
  /* Get the record type and lenght of the record. Adjust the checksum   */
  /* byte accordingly.                                                   */
  /*---------------------------------------------------------------------*/
  rec_type = *sbuf_ptr++ - '0'; 
  CS = (rec_len = getbh());
  rec_len--;   
  switch(rec_type)
  {
    case 7:
    case 8:
    case 9:
      /*-------------------------------------------------------------*/
      /* Termination records.  Nothing to do.                        */
      /*-------------------------------------------------------------*/
      i = 11 - rec_type;
      addr = 0;
      while(i--)
      {
        addr = (addr << 8) + getcsbh();
        if(Error)
          return;
      }
      break;
    case 0:
      break;
    case 5:
      /*-------------------------------------------------------------*/
      /* All of these records can be skipped                         */
      /*-------------------------------------------------------------*/
      while(rec_len != 0)
      {
        getcsbh();
        rec_len--;
        if(Error)
          return;
      }
      break;
    case 1:
    case 2:
    case 3:
      /*-------------------------------------------------------------*/
      /* Data record - first read the load address from the record   */
      /* and add in the offset.  The load address is 2, 3, or 4 byte */
      /* pairs, depending on the record type.                        */
      /*-------------------------------------------------------------*/
      addr = 0;
      for(i = 0; i <= rec_type; i++)
      {
        addr = (addr << 8) + getcsbh();
        rec_len--;
      }
      bypass_data = 0;
      if(addr < lowest_address)
      {
        if(!Flash || (Flash && (addr >= FLASH_TOS_FIRE_ENGINE)))
          lowest_address = addr;
        else
          bypass_data = 1;
      }
      if((addr + rec_len) > hight_address)
        hight_address = addr + rec_len;
      if(Error)
        return;
      /* controle si le telechargement est en flash */
      if((addr >= FLASH_TOS_FIRE_ENGINE)
       && (addr < FLASH_TOS_FIRE_ENGINE+SIZE_TOS_FLASH))
        Flash=1;
      addr &= (SIZE_TOS_FLASH-1);
      addr += Mem_Data;
      /*-------------------------------------------------------------*/
      /* Read each byte of data.                                     */
      /*-------------------------------------------------------------*/
      while(rec_len != 0)
      {
        data = getcsbh();
        if(!bypass_data)
          *((unsigned char *)addr++) = data;
        rec_len--;
        if(Error)
          return;
      }
      break;
    default:
      Error = 1;
      break;
  }
  /*---------------------------------------------------------------------*/
  /* Last thing to do is verify the checksum.                            */
  /*---------------------------------------------------------------------*/
  if((rec_type != 0) && (getbh() != (unsigned char)(~CS)))
    Error = 1;
}

/***********************************************************************/
/* conv_rec: Process a buffer full of records                          */
/*                                                                     */
/*  INPUT: buf_ptr: pointer to buffer                                  */
/*         count:   length of buffer                                   */
/* OUTPUT: None                                                        */
/*                                                                     */
/***********************************************************************/
static void conv_rec(char *buf_ptr, long count)
{
  unsigned char c;
/*---------------------------------------------------------------------*/
/* Transfer data from the buffer into the record buffer until a CR,    */
/* NL, or NULL is transferred (any of these is assumed to terminate    */
/* a record).  Then call read_rec() to process the record, and start   */
/* filling the record buffer again.                                    */
/* NOTE: If the buffer ends with a partial record, it will be saved in */
/*       sbuf[].                                                       */
/*---------------------------------------------------------------------*/
  while(count-- > 0)
  {
    c = (*sbuf_ptr++ = *buf_ptr++);
    if(c == '\n' || c == '\r' || c == 0)
    {
      *sbuf_ptr = '\0';
      read_rec();
      if(Error)
        return;
      while(*buf_ptr == '\n' || *buf_ptr == '\r')
      {
        buf_ptr++;
        if(--count <= 0)
          break;
      }
      sbuf_ptr = sbuf;
    }
  }
}

/***********************************************************************/
/* HTML pages                                                          */
/***********************************************************************/

static void add_block(sock_conn *conn, const char *data, int size)
{
  if(size + conn->response_size > conn->response_max_size)
  {
    void *buf = conn->response;
    int len = conn->response_max_size;
    do
      conn->response_max_size += WRITEBUF_SIZE;
    while(size + conn->response_size > conn->response_max_size);
    conn->response = pvPortMalloc2(conn->response_max_size);
    memcpy(conn->response, buf, len);
    vPortFree2(buf);
  }
  if(conn->response != NULL)
  {
    memcpy(&conn->response[conn->response_size], data, size);
    conn->response_size += size;
  }
}

static void a2p(sock_conn *conn, const char *text)
{
  add_block(conn, text, strlen(text));
}

static void add_types(sock_conn *conn)
{
  int i=0;
  while(types1[i])
  {
    a2p(conn, "<option>");
    a2p(conn, types1[i++]);
    a2p(conn, "</option>\n");
  }
}

static void add_types_write(sock_conn *conn)
{
  int i=0;
  while(types2[i])
  {
    a2p(conn, "<option>");
    a2p(conn, types2[i++]);
    a2p(conn, "</option>\n");
  }
}

static void handle_menu(sock_conn *conn, char *request)
{
  static char html[] =
#ifdef MCF5445X
    "<html><head><title>M54455EVB - Menu</title>\n"
#else
#ifdef MCF547X
    "<html><head><title>FIREBEE - Menu</title>\n"
#else /* MCF548X */
    "<html><head><title>M5484LITE - Menu</title>\n"
#endif
#endif
    "<script language='javascript'>\n"
    "<!-- \n"
    "var pathname = location.pathname; \n"
    "var myDomain = pathname.substring(0,pathname.lastIndexOf('/')) +'/'; \n"
    "var date_exp = new Date(); \n"
    /* cookie MCF5485 for 30 days */
    "date_exp.setTime(date_exp.getTime()+(30*24*3600*1000)); \n"
    "var navigateur = navigator.appName; \n"
    "var plateforme = navigator.platform; \n"
    "var BulleBill = false; \n"
    "var Bold = \"<b>\"; \n"
    "var NoBold = \"</b>\"; \n"
    "if(navigateur == \"Microsoft Internet Explorer\") \n"
    "  BulleBill = true; \n"
    "if(plateforme != \"Win32\") \n"
    "  BulleBill = false; \n"
    "if(BulleBill) Bold = NoBold = \"\"; \n"
    "var bulleStyle = null \n"
    "if(!document.layers && !document.all && !document.getElementById) \n"
    "  event=\"chut\"; \n"
    "function bulle(msg,evt,hauteur) { \n"
    "  var xfenetre,yfenetre,xpage,ypage,element=null; \n"
    "  var offset=15; \n"
    "  var bulleWidth=150; \n"
    "  if(BulleBill) return; \n"
    "  if(!hauteur) hauteur=40; \n"
    "  if(document.layers) { \n"
    "    bulleStyle=document.layers['tip']; \n"
    "    bulleStyle.document.write('<layer bgColor=\"#ffffdd\" ' \n"
    "    +'style=\"width:150px;border:1px solid black;color:black\">' \n"
    "    + msg + '</layer>' ); \n"
    "    bulleStyle.document.close(); \n"
    "    xpage = evt.pageX; ypage = evt.pageY; \n"
    "    xfenetre = xpage; yfenetre = ypage; \n"    
    "  } else if(document.all) { \n"
    "    element=document.all['tip'] \n"
    "    xfenetre = evt.x; yfenetre = evt.y; \n"    
    "    xpage=xfenetre; ypage=yfenetre; \n"
    "    if(document.body.scrollLeft) xpage = xfenetre + document.body.scrollLeft; \n"
    "    if(document.body.scrollTop) ypage = yfenetre + document.body.scrollTop; \n"
    "  } else if (document.getElementById) { \n"
    "    element=document.getElementById('tip') \n"
    "    xfenetre = evt.clientX; yfenetre = evt.clientY; \n"
    "    xpage=xfenetre; ypage=yfenetre; \n"  
    "    if(evt.pageX) xpage = evt.pageX; \n"
    "    if(evt.pageY) ypage = evt.pageY ; } \n"
    "  if(element) { \n"
    "    bulleStyle=element.style; \n"
    "    element.innerHTML=msg; } \n"
    "  if(bulleStyle) { \n"
    "    if (xfenetre > bulleWidth+offset) xpage=xpage-bulleWidth-offset; \n"
    "    else xpage=xpage+15; \n"
    "    if( yfenetre > hauteur+offset ) ypage=ypage-hauteur-offset; \n"
    "    bulleStyle.width=bulleWidth; \n"
    "    if(typeof(bulleStyle.left)=='string') { \n"
    "        bulleStyle.left=xpage+'px'; bulleStyle.top=ypage+'px'; \n" 
    "    } else { \n"
    "      bulleStyle.left=xpage; bulleStyle.top=ypage; } \n"
    "    bulleStyle.visibility=\"visible\"; } } \n"
    "function fin_bulle() { \n"
    "  if(bulleStyle) bulleStyle.visibility=\"hidden\"; } \n"
    "function getCookieVal(offset) { \n"
    "  var endstr = document.cookie.indexOf (\";\", offset); \n"
    "  if(endstr==-1) \n"
    "    endstr=document.cookie.length; \n"
    "  return unescape(document.cookie.substring(offset, endstr)); } \n"
    "function GetCookie(name) { \n"
    "  var arg = name+\"=\"; \n"
    "  var alen = arg.length; \n"
    "  var clen = document.cookie.length; \n"
    "  var i=0; \n"
    "  while(i<clen) { \n"
    "    var j=i+alen; \n"
    "    if(document.cookie.substring(i, j)==arg) \n"
    "      return getCookieVal(j); \n"
    "    i = document.cookie.indexOf(\" \",i)+1; \n"
    "    if(i==0) break; } \n"
    "  return null; } \n"
    "function SetCookie(name, value) { \n"
    "  var argv = SetCookie.arguments; \n"
    "  var argc = SetCookie.arguments.length; \n"
    "  var expires = (argc > 2) ? argv[2] : null; \n"
    "  var path = (argc > 3) ? argv[3] : null; \n"
    "  var domain = (argc > 4) ? argv[4] : null; \n"
    "  var secure = (argc > 5) ? argv[5] : false; \n"
    "  document.cookie = name+\"=\"+escape(value)+ \n"
    "   ((expires==null) ? \"\" : (\"; expires=\"+expires.toGMTString()))+ \n"
    "   ((path==null) ? \"\" : (\"; path=\"+path))+ \n"
    "   ((domain==null) ? \"\" : (\"; domain=\"+domain))+ \n"
    "   ((secure==true) ? \"; secure\" : \"\"); } \n"
    "function cherche(name) { \n"
    "  var cookie = GetCookie(\"MCF5485\"); \n"
    "  if(cookie==null) \n"
    "    return null; \n"
    "  recherche = cookie.indexOf(name); \n"
    "  if(recherche==-1) \n"
    "    return null; \n"
    "  var extrait = cookie.slice(recherche); \n"
    "  var variable = extrait.slice(extrait.indexOf('_')+1, extrait.indexOf('|')); \n"
    "  return variable; } \n"
    "function sauve() { \n"
    "  SetCookie(\"MCF5485\", \n"
    "   document.forms[0].LectMem.name + \"_\" + document.forms[0].LectMem.selectedIndex + \"|\" \n"
    "   + document.forms[0].OffsetLect.name + \"_\" + document.forms[0].OffsetLect.value + \"|\" \n"
    "   + document.forms[0].LengthLect.name + \"_\" + document.forms[0].LengthLect.value + \"|\" \n"
    "   + document.forms[0].Rafraichir.name + \"_\" + document.forms[0].Rafraichir.value + \"|\" \n"
    "   + document.forms[0].ModifMem.name + \"_\" + document.forms[0].ModifMem.selectedIndex + \"|\" \n"
    "   + document.forms[0].IndexModif.name + \"_\" + document.forms[0].IndexModif.value + \"|\" \n"
    "   + document.forms[0].OffsetDis.name + \"_\" + document.forms[0].OffsetDis.value + \"|\" \n"
    "   + document.forms[0].LengthDis.name + \"_\" + document.forms[0].LengthDis.value + \"|\" \n"
    "   , date_exp); } \n"
    "function remplissage() { \n"
    "  var LectMem = cherche(\"LectMem\"); \n"
    "  if(LectMem != null) \n"
    "    document.forms[0].LectMem.selectedIndex = parseInt(LectMem); \n"
    "  var OffsetLect = cherche(\"OffsetLect\"); \n"
    "  if(OffsetLect != null) \n"
    "    document.forms[0].OffsetLect.value = OffsetLect; \n"
    "  var LengthLect = cherche(\"LengthLect\"); \n"
    "  if(LengthLect != null) \n"
    "    document.forms[0].LengthLect.value = LengthLect; \n"    
    "  var Rafraichir = cherche(\"Rafraichir\"); \n"
    "  if(Rafraichir != null) \n"
    "    document.forms[0].Rafraichir.value = Rafraichir; \n"
    "  var ModifMem = cherche(\"ModifMem\"); \n"
    "  if(ModifMem != null) \n"
    "    document.forms[0].ModifMem.selectedIndex = parseInt(ModifMem); \n"
    "  var IndexModif = cherche(\"IndexModif\"); \n"
    "  if(IndexModif != null) \n"
    "    document.forms[0].IndexModif.value = IndexModif; \n"
    "  var OffsetDis = cherche(\"OffsetDis\"); \n"
    "  if(OffsetDis != null) \n"
    "    document.forms[0].OffsetDis.value = OffsetDis; \n"
    "  var LengthDis = cherche(\"LengthDis\"); \n"
    "  if(LengthDis != null) \n"
    "    document.forms[0].LengthDis.value = LengthDis; \n"
    "} \n"
    "// --> \n"
    "</script>\n"    
    "</head>\n";
  static char menu[] =
    "<body bgcolor=cyan text=black onLoad='remplissage()'>\n"
    "<div id='tip' style='position:absolute; visibility:hidden; z-index:800; "
    "background:#ffa; width:150px; height:auto; padding:4px; text-align:left; "
    "border:2px solid black;'>\n"
    "Il a quelques navigateurs o&ugrave; les bulles ne fonctionnent pas...</div>\n"  
    "<p><center><font color=blue size=5><i><b>"
#ifdef MCF5445X
    "M54455EVB"
#else
#ifdef MCF547X
    "FIREBEE"
#else /* MCF548X */
    "M5484LITE"
#endif
#endif    
    "</b></i></font><br>\n<i>Basic WEB Server version ";
  static char menu1[] =
    "</i><br><hr size=1 color=blue><br></center>\n"
    "<p><h3>Menu :</h3>\n"
    "<form action='/mem.html' method='get'>\n"
    "<p><script language='javascript'>\n"
    "<!-- \n"
    "  var message1 = \"Allows to see memory from a type of size with a refresh rate of 1 to 99 seconds. \"; \n"
    "  if(BulleBill) document.write(\"<span title='\" + message1 + \"'>\"); \n"
    "  else document.write(\"<span>\"); \n"
    "// --> \n"
    "</script>\n"
    "<b onMouseOver='this.style.color=\"blue\"; bulle(message1, event);' onMouseOut='this.style.color=\"black\"; fin_bulle();'> \n"
    "Reading memory : </b></span>\n"
    "<select name='LectMem'>\n";
  static char menu2[] =
    "</select>\n Start address $<input type='text' value='0' name='OffsetLect' size=8 maxlength=8>\n"
    " Length <input type='int' value='16' name='LengthLect' size=3 maxlength=3>\n"
    " Refresh rate <input type='int' value='1' name='Rafraichir' size=2 maxlength=2> S\n"
    "<input type='submit' value='OK' name='ChoixLect' onClick='sauve()'>\n"
    "<p><script language='javascript'>\n"
    "<!-- \n"
    "  var message2 = \"Allows to change memory from his address. After his modification, the value from the reading page is displayed in bold. \"; \n"
    "  if(BulleBill) document.write(\"<span title='\" + message2 + \"'>\"); \n"
    "  else document.write(\"<span>\"); \n"
    "// --> \n"
    "</script>\n"
    "<b onMouseOver='this.style.color=\"blue\"; bulle(message2, event);' onMouseOut='this.style.color=\"black\"; fin_bulle();'> \n"
    "Change memory : </b></span>\n"
    "<select name='ModifMem'>\n";
  static char menu3[] =
    "</select>\n Address $<input type='text' name='IndexModif' size=8 maxlength=8>\n"
    " Value <input type='text' name='ValeurModif' size=8 maxlength=10>\n"
    "<input type='submit' value='OK' name='ChoixModif' onClick='sauve()'>\n"
    "<p><script language='javascript'>\n"
    "<!-- \n"
    "  var message4 = \"Allows to disassemble memory. \"; \n"
    "  if(BulleBill) document.write(\"<span title='\" + message4 + \"'>\"); \n"
    "  else document.write(\"<span>\"); \n"
    "// --> \n"
    "</script>\n"
    "<b onMouseOver='this.style.color=\"blue\"; bulle(message4, event);' onMouseOut='this.style.color=\"black\"; fin_bulle();'> \n"
    "Disassemble memory : </b></span>\n"
    " Start address $<input type='text' value='E00030' name='OffsetDis' size=8 maxlength=8>\n"
    " Length <input type='int' value='32' name='LengthDis' size=3 maxlength=3>\n"
     "<input type='submit' value='OK' name='ChoixDis' onClick='sauve()'>\n" 
    "<p><script language='javascript'>\n"
    "<!-- \n"
    "  var message6 = \"Start a Telnet connection on the phyCORE-MCF548x for get the shell CMD, however it is not a pROBE (pSOS) replacement but some commands, machine working, like \" \n"
    "   + Bold + \"pm\" + NoBold + \", \" + Bold + \"dm\" + NoBold + \" or \" + Bold + \"qt\" + NoBold + \" are added. \"; \n"
    "  if(BulleBill) document.write(\"<span title='\" + message6 + \"'>\"); \n"
    "  else document.write(\"<span>\"); \n"
    "// --> \n"
    "</script>\n"
    "<b onMouseOver='this.style.color=\"blue\"; bulle(message6 ,event);' onMouseOut='this.style.color=\"black\"; fin_bulle();'> \n"
    "Commands shell : </b></span><input type='button' value='CMD via Telnet' onClick='location=\"telnet://";
  static char menu4[] =  
    "<p><script language='javascript'>\n"
    "<!-- \n"
    "  var message5 = \"Access to the upload program page in srecord format (.HEX), however the unknow files are copied inside the ram disk of 16 MB. \"; \n"
    "  if(BulleBill) document.write(\"<span title='\" + message5 + \"'>\"); \n"
    "  else document.write(\"<span>\"); \n"
    "// --> \n"
    "</script>\n"
    "<b onMouseOver='this.style.color=\"blue\"; bulle(message5 ,event);' onMouseOut='this.style.color=\"black\"; fin_bulle();'> \n"
    "Upload : </b></span><input type='submit' value='File' name='EnvoiFichier' onClick='sauve()'>\n"
    "<p><hr size=1 color=blue>\n"
    "</form>\n";
  static char end[] = "</body></html>";
  unsigned long IP;
  struct in_addr addr;
  char buf[64];
  a2p(conn, html);
  a2p(conn, menu);
  ltoa(buf, VERSION_WEB, 16);
  a2p(conn, buf);
  a2p(conn, menu1);
  add_types(conn);
  a2p(conn, menu2);
  add_types_write(conn);
  a2p(conn, menu3);
  board_get_client((unsigned char *)&IP);
  addr.s_addr = htonl(IP);
  a2p(conn, inet_ntoa(addr));
  a2p(conn, "\"'>\n");
  a2p(conn, menu4);
  a2p(conn, end);
}

static void handle_mem(sock_conn *conn, char *req)
{
  static char html[] =
    "<html><head>\n<title>phyCORE-MCF548x</title>\n"
    "</head>\n";
  static char refresh[] =
    "<html><head>\n<title>phyCORE-MCF548x - Mem</title>\n"
    "<script language='javascript'>\n"
    "<!-- \n"
    "function exportToXL(eSrc) { \n"
    "  var oExcel; \n"
    "  var oExcelSheet; \n"
    "  var oWkBooks; \n"
    "  var cols; \n"
    "  oExcel = new ActiveXObject('Excel.Application'); \n"
    "  oWkBooks = oExcel.Workbooks.Add; \n"
    "  oExcelSheet = oWkBooks.Worksheets(1); \n"
    "  oExcelSheet.Activate(); \n"
    "  if(eSrc.tagName != 'TABLE') \n"
    "    return false; \n"
    "  cols = Math.ceil(eSrc.cells.length / eSrc.rows.length); \n"
    "  for(var i = 0; i < eSrc.cells.length; i ++) { \n"
    "    var c, r; \n"
    "    r = Math.ceil((i+1) / cols); \n"
    "    c = (i+1)-((r-1)*cols) \n"
    "    if(eSrc.cells(i).tagName == 'TH') { \n"
    "      oExcel.ActiveSheet.Cells(r,c).Font.Bold = true; \n"
    "      oExcel.ActiveSheet.Cells(r,c).Interior.Color = 14474460; } \n"
    "    if(eSrc.cells(i).childNodes.length > 0 && eSrc.cells(i).childNodes(0).tagName == \"B\") \n"
    "      oExcel.ActiveSheet.Cells(r,c).Font.Bold = true; \n"
    "    oExcel.ActiveSheet.Cells(r,c).Value = eSrc.cells(i).innerText; } \n"
    "  oExcelSheet.Application.Visible = true; } \n"
    "// --> \n"
    "</script>\n"
    "<meta http-equiv='refresh' content='";
  static char redirection_fichier[] =
    "<html><head>\n<title>phyCORE-MCF548x</title>\n"
    "<meta http-equiv='refresh' content='0; url=/sel_file.html'>\n"
    "</head>\n"
    "<body>\n<a href='/sel_file.html'></a>\n";
  static char imprimer[] = 
    "<form><p align=right>\n"
    "<input type='button' value='MENU' name='MENU' onClick='document.location.href=\"/menu.html\"'>\n"
    "<input type='button' value='EXCEL' name='EXCEL' onCLick='exportToXL(oForm.all(\"idTable\"))'>\n"
    "<input type='button' value='PRINT' name='IMPRIMER' onClick='window.print()'>\n"
    "</p></form>\n";   
  static char imprimer2[] = 
    "<form><p align=right>\n"
    "<input type='button' value='MENU' name='MENU' onClick='document.location.href=\"/menu.html\"'>\n"
    "<input type='button' value='PRINT' name='IMPRIMER' onClick='window.print()'>\n"
    "</p></form>\n";   
  static char retour[] = 
    "<form>\n"
    "<input type='button' value='BACK' name='RETOUR' onClick='history.back()'>\n"
    "</form>\n";  
  static char end[] = "</body></html>";
  int Refresh=1;
  int i,j,max_align,max,choix,ChoixMem,OffsetLect=0,LengthLect=1,IndexMem=0;
  int  OffsetDis=0,LengthDis=8;
  unsigned long bits;  
  float val;
  char body[64],buf[BUF_SIZE],buf2[BUF_SIZE];
  char *ptr, *ptr2;
  short *sptr;
  double *dptr;
  int len;
  long *mem=NULL;
  ptr = strchr(req, '?');
  if(ptr == NULL)
    ptr = req;
  else
    ptr++;
  ptr2 = buf;
  i = 0;
  while(*ptr && (*ptr != ' ') && (i++ < BUF_SIZE-1))
    *ptr2++ = *ptr++;
  *ptr2 = 0;
  if((ptr = strstr(buf, "ColorMem=")) != NULL
   && ptr[9]!='&' && ptr[9])
  {
    buf2[6] = 0;
    memcpy(buf2, &ptr[9], 6);
    strcpy(body, "<body bgcolor=#");
    strcat(body, buf2);
    strcat(body, ">\n<p>\n");
  }  
  else
    strcpy(body, "<body bgcolor=#FFFF7F>\n<p>\n");
/*************************** ENVOI FICHIER ************************************/
  if(strstr(buf, "EnvoiFichier=") != NULL)
    a2p(conn, redirection_fichier);
/**************************** DISASSEMBLE *************************************/
  else if(strstr(buf, "ChoixDis=") != NULL)
  {
    struct DisasmPara_68k dp;
    char buffer[16];
    m68k_word *ip, *p;
    char opcode[16];
    char operands[128];
    char iwordbuf[32];
    char *s;
    int n, i;
    if((ptr = strstr(buf, "OffsetDis=")) != NULL
     && ptr[10]!='&')
    {
      ptr[9] = '$';
      OffsetDis = (int)atol(&ptr[9]);
      ptr[9] = '=';
    }
    else
      OffsetDis = 0;
    if((ptr = strstr(buf, "LengthDis=")) != NULL
     && ptr[10]!='&')
    {
      LengthDis = (int)atol(&ptr[10]);
      if(LengthDis < 0)
        LengthDis = 8;
      else if(LengthDis > 999)
        LengthDis = 999;
    }
    else
      LengthDis = 1;
    a2p(conn, html);
    a2p(conn, body);
    a2p(conn, "<pre>\r\n");
    p=(m68k_word *)OffsetDis;
    db_radix = 16;
    dp.instr = NULL;              /* pointer to instruction to disassemble */
    dp.iaddr = NULL;              /* instr.addr., usually the same as instr */
    dp.opcode = opcode;           /* buffer for opcode, min. 16 chars. */
    dp.operands = operands;       /* operand buffer, min. 128 chars. */
    dp.radix = 16;                /* base 2, 8, 10, 16 ... */
/* call-back functions for symbolic debugger support */
    dp.get_areg = NULL;           /* returns current value of reg. An */
    dp.find_symbol = NULL;        /* finds closest symbol to addr and */
                                  /*  returns (positive) difference and name */
/* changed by disassembler: */
    dp.type = 0;                  /* type of instruction, see below */
    dp.flags = 0;                 /* additional flags */
    dp.reserved = 0;
    dp.areg = 0;                  /* address reg. for displacement (PC=-1) */
    dp.displacement = 0;          /* branch- or d16-displacement */
    for(i=0;i<LengthDis;i++)
    {          
      for(n = 0; n<sizeof(opcode)-1; opcode[n++]=' ');
      opcode[n] = 0;
      for(n = 0; n<sizeof(operands); operands[n++]=0);
      dp.instr = dp.iaddr = p;
      p = M68k_Disassemble(&dp);
      /* print up to 5 instruction words */
      for(n = 0; n<26; iwordbuf[n++]=' ');
      iwordbuf[26] = 0;
      if((n = (int)(p-dp.instr)) > 5)
        n = 5;
      ip = dp.instr;
      s = iwordbuf;
      while(n--)
      {
        ltoa(buffer,(((unsigned long)*(unsigned char *)ip)<<8) | ((unsigned long)*((unsigned char *)ip+1)) | 0x10000UL,16);
        *s++ = buffer[1];
        *s++ = buffer[2];
        *s++ = buffer[3];
        *s++ = buffer[4];
        s++;
          ip++;
      }
      a2p(conn, "$");
      ltoa(buffer,(unsigned long)dp.iaddr,16);
      a2p(conn, buffer);
      a2p(conn, ": ");
      a2p(conn, iwordbuf);
      strcpy(buffer, "       ");
      n = 0;
      while(opcode[n])
      {
        buffer[n] = opcode[n];
        n++;
      }
      buffer[n] = 0;
      a2p(conn, buffer);
      a2p(conn, " ");
      a2p(conn, operands);
      a2p(conn, "\r\n");
    }
    a2p(conn, "</pre>\r\n");
    a2p(conn, imprimer);
    goto EndMem;
  }
/*************************** MODIFICATION VARIABLE ****************************/
  else if(strstr(buf, "ChoixModif=") != NULL)
  {
    ChoixMem = 0;
    choix = 1;
    while(types2[choix] != NULL)
    {
      strcpy(buf2, "ModifMem=");
      strcat(buf2, types2[choix]);
      len = strlen(buf2);
      if((ptr2 = strstr(buf, buf2)) != NULL
       && (ptr2[len]=='&' || ptr2[len]==0))
      {
        if((ptr = strstr(buf, "IndexModif=")) != NULL
         && ptr[11]!='&')
        {
          ptr[10] = '$';
          mem = (long *)atol(&ptr[10]);
          ptr[10] = '=';
          if((ptr = strstr(buf, "ValeurModif=")) != NULL
           && ptr[12]!='&')
          {
            val = atof(&ptr[12]);
            if(1)
            {
              if(strcmp(types2[choix], "BYTE") == 0)
                *(char *)mem = (char)val; 
              else if(strcmp(types2[choix], "SHORT") == 0)
                *(short *)mem = (short)val; 
              else if(strcmp(types2[choix], "FLOAT") == 0)
                *(float *)mem = val;
              else if(strcmp(types2[choix], "DOUBLE") == 0)
                *(double *)mem = (double)val; 
              else
                *mem = (long)val;
              ChoixMem = 0;
              while(types1[ChoixMem] != NULL)
              {
                if(strcmp(types1[ChoixMem], types2[choix]) == 0)
                {
                  ChoixMem++;
                  OffsetLect = (int)mem;
                  IndexMem = (int)mem;
                  LengthLect = 16;
                  a2p(conn, html);
                  goto AffMem;
                }
                ChoixMem++;
              }
              ChoixMem = 0;
              OffsetLect = (int)mem;
              IndexMem = (int)mem;
              LengthLect = 16;
              a2p(conn, html);
              goto AffMem;              
            }
            else
            {
              a2p(conn, html);
              a2p(conn, "<body bgcolor=red>\n<h3>Bad address</h3>\n");
              a2p(conn, retour);
              goto EndMem;
            }
          }
          else
          {
            a2p(conn, html);
            a2p(conn, "<body bgcolor=red>\n<h3>No value for this address</h3>\n");    
            a2p(conn, retour);
            goto EndMem;
          }
        }
        else
        {
          a2p(conn, html);
          a2p(conn, "<body bgcolor=red>\n<h3>No address</h3>\n");
          goto EndMem;
        }
      }
      choix++;
    }
    a2p(conn, html);
    a2p(conn, "<body bgcolor=red>\n<h3>Impossible to change this address</h3>\n");
    a2p(conn, retour);
  }
/*************************** LECTURE VARIABLES ********************************/
  else if(strstr(buf, "ChoixLect=") != NULL)
  {
    a2p(conn, refresh);
    if((ptr = strstr(buf, "Rafraichir=")) != NULL
     && ptr[11]!='&')
      Refresh = (int)atol(&ptr[11]);
    if(Refresh == 0)
      Refresh++;
    ltoa(buf2, Refresh, 10);
    a2p(conn, buf2);
    a2p(conn, "'>\n</head>\n");
    if((ptr = strstr(buf, "OffsetLect=")) != NULL
     && ptr[11]!='&')
    {
      ptr[10] = '$';
      OffsetLect = (int)atol(&ptr[10]);
      ptr[10] = '=';
    }
    else
      OffsetLect = 0;
    if((ptr = strstr(buf, "LengthLect=")) != NULL
     && ptr[11]!='&')
    {
      LengthLect = (int)atol(&ptr[11]);
      if(LengthLect < 0)
        LengthLect = 1;
      else if(LengthLect > MAX_LENGTH)
        LengthLect = MAX_LENGTH;
    }
    else
      LengthLect = 1;
    ChoixMem = 0;
AffMem:
    a2p(conn, body);
    mem = (long *)OffsetLect;
    choix = 0;
    while(types1[choix] != NULL)
    {
      strcpy(buf2, "LectMem=");
      strcat(buf2, (ptr = types1[choix]));
      len = strlen(buf2);
      if(((ptr2 = strstr(buf, buf2)) != NULL
       && (ptr2[len]=='&' || ptr2[len]==0)) || ChoixMem)
      {
        if(!ChoixMem || (choix+1)==ChoixMem)
        {
          a2p(conn, "<form id=oForm><table id=idTable name=idTable border width=100%%>\n<caption><h3>Table ");
          a2p(conn, ptr);
          a2p(conn, "</h3></caption>\n");
          if(strcmp(types1[choix], "BIT") == 0)
          {
            for(i=0; i<LengthLect; i++)
            {
              a2p(conn, "<tr>\n");
              bits = (unsigned long)mem[i];
              bits = ((bits & 0xFF)<<24) + ((bits & 0xFF00)<<8)
               + ((bits & 0xFF0000)>>8) + ((bits & 0xFF000000)>>24);
              for(j=0; j<32; j++)
              {
                if(j==16)
                  a2p(conn, "</tr>\n<tr>\n");
                a2p(conn, "<td width=6%% align=center>"); 
                ltoa(buf2, i*32 + j + 1, 10);
                a2p(conn, buf2);
                if(bits&1)
                  a2p(conn, "<br><img src='/gif/green_led.gif' width=10 height=10></td>\n");
                else
                  a2p(conn, "<br><img src='/gif/red_led.gif' width=10 height=10></td>\n");
                bits >>= 1;
              }
              a2p(conn, "</tr>\n");
            }
          }
          else
          {
            max_align = (LengthLect + 15) & ~15;
            max = LengthLect;
            for(i=0; i<max_align; i++)
            {
              if(!(i&15))
              {
                a2p(conn, "<tr>\n<td><b>$");
                ltoa(buf2, (long)&mem[i], 16);
                a2p(conn, buf2);
                a2p(conn, "</b></td>");
              }
              if(i<max)
              { 
                if(ChoixMem && i == IndexMem)
                {
                  a2p(conn, "<td width=5%%><b>");
                  if(strcmp(types1[choix], "BYTE") == 0)
                  {
                    ptr = (char *)mem; 
                    ltoa(buf2, (long)ptr[i], 10);  
                  }
                  else if(strcmp(types1[choix], "SHORT") == 0)
                  {
                    sptr = (short *)mem; 
                    ltoa(buf2, (long)sptr[i], 10);
                  }
                  else if(strcmp(types1[choix], "LONG") == 0)
                    ltoa(buf2, mem[i], 10);
                  else if(strcmp(types1[choix], "FLOAT") == 0)
                    ftoa(*(float *)&mem[i], 2, buf2);
                  else if(strcmp(types1[choix], "DOUBLE") == 0)
                  {
                    dptr = (double *)mem; 
                    ftoa((float)dptr[i], 2, buf2);
                  }
                  else
                  {
                    buf2[0] = '$';
                    ltoa(&buf2[1], mem[i], 16);
                  }
                  a2p(conn, buf2);
                  a2p(conn, "</b></td>");
                }
                else
                {
                  a2p(conn, "<td width=5%%>");
                  if(strcmp(types1[choix], "BYTE") == 0)
                  {
                    ptr = (char *)mem; 
                    ltoa(buf2, (long)ptr[i], 10);  
                  }
                  else if(strcmp(types1[choix], "SHORT") == 0)
                  {
                    sptr = (short *)mem; 
                    ltoa(buf2, (long)sptr[i], 10);
                  }
                  else if(strcmp(types1[choix], "LONG") == 0)
                    ltoa(buf2, mem[i], 10);
                  else if(strcmp(types1[choix], "FLOAT") == 0)
                    ftoa(*(float *)&mem[i], 2, buf2);
                  else if(strcmp(types1[choix], "DOUBLE") == 0)
                  {
                    dptr = (double *)mem; 
                    ftoa((float)dptr[i], 2, buf2);
                  }
                  else
                  {
                    buf2[0] = '$';
                    ltoa(&buf2[1], mem[i], 16);                
                  }
                  a2p(conn, buf2);
                  a2p(conn, "</td>");
                }
              }
              else
                a2p(conn, "<td>-</td>");
              if((i&15)==15)
                a2p(conn, "\n</tr>\n");
            }
          }
          a2p(conn, "</table></form>\n");
          if(strcmp(types1[choix], "BIT") == 0)
            a2p(conn, imprimer2);
          else            
            a2p(conn, imprimer);
        }
      }
      choix++;
    }
  }
  else
  {
    a2p(conn, html);
    a2p(conn, body);
  }
EndMem:
  a2p(conn, end);
}

static void show_red_led(sock_conn *conn, char *request)
{
  if(request);
  add_block(conn, (const char *)red_led_gif, sizeof(red_led_gif));
}

static void show_green_led(sock_conn *conn, char *request)
{
  if(request);
  add_block(conn, (const char *)green_led_gif, sizeof(green_led_gif));
}

static void select_file(sock_conn *conn, char *request)
{
  static char html[] =
    "<html><head><title>phyCORE-MCF548x - File</title>\n"
    "</head>\n";
  static char form[] =
    "<body bgcolor=#FFFF7F'>\n"
    "<p><center><font color=blue size=5><i><b>"
    "Upload file / system"
    "</b></i></font><br><hr size=1 color=blue><br></center>\n"
    "<p><form action='/file.html' enctype='multipart/form-data' method='post'>\n"
    "<p>Send file : \n"
    "<input type='hidden' value='' name='CheminFichier' id='CheminFichier'>\n"
    "<input type='file' value='' name='Fichier' size=60>\n"
    "<input type='button' value='Send' name='EnvoiFichier' onClick='document.forms[0].CheminFichier.value = document.forms[0].Fichier.value; submit();'>\n"
    "<input type='button' value='MENU' name='MENU' onClick='document.location.href=\"/menu.html\"'>\n"
    "</form>\n";
  static char end[] = "</body></html>";
  if(request);
  a2p(conn, html);
  a2p(conn, form);
  a2p(conn, end);
}

static void handle_file(sock_conn *conn, char *req)
{
  static char html[] =
    "<html><head><title>phyCORE-MCF548x - End File Transfer</title>\n";
  static char retour[] = 
    "<p><form>\n"
    "<input type='button' value='BACK' name='RETOUR' onClick='history.back()'>\n"
    "</form>\n";   
  static char end[] = "</body></html>";
  char *buffer, *ptr, *ptr2, *ptr3;
  char buf[BUF_SIZE], buf2[BUF_SIZE];
  unsigned long len = (unsigned long)conn->content_length;
  int err,i;
  a2p(conn, html);
  if((buffer = (char *)strstr(req, "\r\n\r\n")) == NULL) /* jump header */
    buffer = req;
  memcpy(buf, buffer, BUF_SIZE-1);
  buf[BUF_SIZE-1] = 0;
  minus(buf);
  if((ptr = (char *)strstr(buf, "content-disposition: ")) != NULL)
  {
    ptr2 = (char *)strstr(ptr-buf+buffer, "CheminFichier");
    if((ptr = (char *)strstr(ptr, "content-type: ")) != NULL)
    {
      ptr = ptr-buf+buffer;
      i=0;                            /* mime decoding light !!! */
      while((*ptr++ != '\n') && (i < 4096))
        i++;
      while((*ptr++ != '\n') && (i < 4096))
        i++;
      len -= (unsigned long)(ptr-buffer);
      ptr3 = ptr;                     /* beginning of file */
      if((i = strlen(conn->boundary)) != 0)
      {
        while(ptr3 < &ptr[len])
        {
          if(*ptr3 == '-')
          {
            if(memcmp(ptr3, conn->boundary, i) == 0)
            {
              len = (unsigned long)(ptr3-ptr); /* fix size */
              if(ptr3[-4]== '\r' &&  ptr3[-3]== '\n' && ptr3[-2]== '-' && ptr3[-1]== '-')
                len -= 4;
              break;
            }
          }
          ptr3++;             
        }
      }
      else /* normally unused in boundary found before */
      {
        while(ptr3 < &ptr[len])
        {
          if(*ptr3 == '-')
          {
            i=0;
            while(ptr3[i++] == '-');    /* boundary -------------XXXXXXXXX */
            if(i >= 20)
            {
              if(ptr3[-1] == '\n')
                ptr3--;
              if(ptr3[-1] == '\r')
                ptr3--;
              len = (unsigned long)(ptr3-ptr); /* fix size */
              break;
            }
          }
          ptr3++; 
        }
      }
      i=0;
      while(i<40) /* beginning of file */
      {
        if(((unsigned char)ptr[i])>=' '&& ((unsigned char)ptr[i])<='z'
         && ptr[i]!='<' && ptr[i]!='>' && ptr[i]!='/' && ptr[i]!=';')
          buf2[i] = ptr[i];
        else
          buf2[i] = ' ';
        i++;
      }
      buf2[i] = 0;
      buf[0] = 0;
      if(ptr2 != NULL) /* extract host path from POST string */
      {
        i=0;
        while((*ptr2++ != '\n') && (i < 4096))
          i++;
        while((*ptr2++ != '\n') && (i < 4096))
          i++;
        i=0;
        while((ptr2[i] != '\n') && (ptr2[i] != '\r') && (i < BUF_SIZE))
        {
          buf[i] = ptr2[i];
          i++;
        }
        buf[i] = 0;
      }
      /* chargement .HEX */
      Mem_Data = 0;
      Flash = Error = 0;
      sbuf_ptr = sbuf;
      lowest_address = 0xFFFFFFFF;
      hight_address = 0;
      conv_rec(ptr, (long)len);
      if(Error)
      {
        a2p(conn, "<body bgcolor=red>\n<h3>Srecord file .HEX error : ");
        a2p(conn, buf);
        err = (int)copy_file(buf, ptr, (long)len);
        a2p(conn, "</h3>\nBeginning of the file <b>[</b> ");
        a2p(conn, buf2);
        a2p(conn, " <b>]</b><br><br>\n");
        a2p(conn, buf);
        if(err==0)
          a2p(conn, "<br>File copied inside the disk<br>\n");
        a2p(conn, retour);
      }
      else
      {
        if(Flash)
        {
          if((err=Programmation(lowest_address,hight_address,lowest_address-FLASH_TOS_FIRE_ENGINE+Mem_Data)) < 0)
          {
            a2p(conn, "<body bgcolor=red>\n<h3>Programming/verify error</h3>\n");
            a2p(conn, retour);
          }
          else
          {
            a2p(conn, "<body bgcolor=white>\n<br>\n");
            a2p(conn, "<p><h3>System copied in flash : ");
            a2p(conn, buf);              
            a2p(conn, "</h3><br>\n");   
            a2p(conn, retour);
          }
        }
        else
        {
          a2p(conn, "<body bgcolor=red>\n<h3>File not for the flash : ");
          a2p(conn, buf);         
          err = (int)copy_file(buf, ptr, (long)len);
          a2p(conn, "</h3><br>\n");
          if(err==0)
            a2p(conn, "<br>File copied inside the ram disk<br>\n");
          a2p(conn, retour);
        }
      }
      a2p(conn, end);
      return;
    }
  }
  a2p(conn, "<body bgcolor=red>\n<h3>Content not valid</h3><br>\n");
  a2p(conn, retour);
  a2p(conn, end);
}

static http_list m_http_list[] = {
  { "GET", "/index.html", handle_menu, "text/html"},
  { "GET", "/menu.html", handle_menu, "text/html"},
  { "GET", "/mem.html", handle_mem, "text/html" },
  { "GET", "/gif/red_led.gif", show_red_led, "image/gif" },
  { "GET", "/gif/green_led.gif", show_green_led, "image/gif" },
  { "GET", "/sel_file.html", select_file, "text/html" },
  { "POST","/file.html", handle_file, "text/html" },
  { "GET", "/", handle_menu, "text/html" },
  { NULL, NULL, NULL, NULL }
};

static void handle_url(sock_conn *conn, char *request)
{
  int i = 0, size;
  char *ptr;
  char path[256];
  if((memcmp(request, "GET", 3) != 0) && (memcmp(request, "POST", 4) != 0))
  {
     send_status_code(conn, 501); /* not implemented */
    return;
  }
  while(m_http_list[i].url != NULL)
  {
    size = strlen(m_http_list[i].method);
    if(memcmp(request, m_http_list[i].method, size) == 0)
    {
       ptr = &request[size];
      if(*ptr == ' ')
        ptr++;
      if(memcmp(ptr, m_http_list[i].url, strlen(m_http_list[i].url)) == 0)
      {
        unsigned long time = gettime();
        send_status_code(conn, 200); /* OK */
        m_http_list[i].handle_url(conn, request);
        send_date(conn, "Date: ", gettime());
        write_string(conn, "Server: LWIP/1.2.0\r\nAllow: GET, POST\r\nConnection: close\r\n");
        send_content_type(conn, m_http_list[i].content_type);
        send_content_length(conn, conn->response_size);
        send_date(conn, "Last-Modified: ", time);
//        write_string(conn, "\r\n");
        write_socket(conn, "\r\n", 2 , 1); /* flush */
        /* write out the dynamically generated page */    
        write_socket(conn, conn->response, conn->response_size, 1); /* flush */
        return;
      }
    }
    i++;
  }
  if(memcmp(request, "GET", 3) == 0)
  {
    ptr = &request[3];
    if(*ptr == ' ')
      ptr++;
    if(strlen(ptr) < 200)
    {
      long handle, len;
      char *buf;
      strcpy(path, "C:\\html");
      strcat(path, ptr);
      i = 3;
      while(path[i])
      {
        if(path[i] == '/')
          path[i] = '\\';
        else if((path[i] == '?') || (path[i] == ' '))
        {
          path[i] = '\0';
          break;
        }
        else if((path[i] >= 'A') && (path[i] <= 'Z'))
          path[i] += 0x20; /* minus */
        i++;  
      }
      handle = Fopen(path, 0);
      if(handle >= 0)
      {
        len = Fseek(0, handle, 2);
        if(len > 0)
        {
          Fseek(0, handle, 0);
          buf = (char *)pvPortMalloc2(len);
          if(buf)
          {
            if(Fread(handle, len, buf) >= 0)
            {
              char *p = &path[strlen(path)-3];
              unsigned long time = gettime();
              send_status_code(conn, 200); /* OK */
              send_date(conn, "Date: ", gettime());
              write_string(conn, "Server: LWIP/1.2.0\r\nAllow: GET, POST\r\nConnection: close\r\n");
              if(strcmp(p, "htm") == 0)
                send_content_type(conn, "text/html");
              else if(strcmp(p, "css") == 0)
                send_content_type(conn, "text/css");
              else if(strcmp(p, "gif") == 0)
                send_content_type(conn, "image/gif");
              else if(strcmp(p, "jpg") == 0)
                send_content_type(conn, "image/jpeg");
              else if(strcmp(p, "png") == 0)
                send_content_type(conn, "image/png");
              else if(strcmp(p, "wav") == 0)
                send_content_type(conn, "audio/x-wav");
              else if(strcmp(p, "mpg") == 0)
                send_content_type(conn, "video/mpg");
              else if(strcmp(p, "pdf") == 0)
                send_content_type(conn, "application/pdf");
              else if(strcmp(p, "jar") == 0)
                send_content_type(conn, "application/x-java-archive");
              else
                send_content_type(conn, "application/octet-stream");
              send_content_length(conn, len);
              send_date(conn, "Last-Modified: ", time);
              write_string(conn, "\r\n");
              write_socket(conn, buf, len, 1);  /* flush */
              vPortFree2(buf);
              Fclose(handle);
              return;
            }
          }        
          vPortFree2(buf);
        }
        Fclose(handle);        
      }
    }
  }
  send_status_code(conn, 404); /* not found */
}

/*
 * Process an incoming connection on port 80.
 *
 * This simply checks to see if the incoming data contains a GET request, and
 * if so sends back a single dynamically created page.  The connection is then
 * closed.
 */
static void vProcessConnection(void *pvParameters)
{
  sock_msg *msg;
  sock_conn conn;
  char *pcRxString, *pcRxStringMinus;
  char *ptr, *ptr2;
  int sock, len, size_header, i;
  int task = (int)pvParameters;
  if(task);
  conn.buf_write = (char *)pvPortMalloc2(WRITEBUF_SIZE);
  pcRxString = (char *)pvPortMalloc2(READBUF_SIZE+1);
  pcRxStringMinus = (char *)pvPortMalloc2(READBUF_SIZE+1);
  if((mbox == NULL) || (conn.buf_write == NULL)
   || (pcRxString == NULL) || (pcRxStringMinus == NULL))
  {
    while(1)
      vTaskDelay(1);
  }
  while(1)
  {
    if(!xQueueReceive(mbox, &msg, portMAX_DELAY))
      continue;
    sock = msg->sock;
    conn.response_max_size = WRITEBUF_SIZE;
    conn.response = (char *)pvPortMalloc2(conn.response_max_size);
    conn.content_length = size_header = 0;
    conn.errno = conn.response_size = conn.offset_buf_write = 0;
    conn.sock = sock;
    conn.boundary[0] = 0;
    if(conn.response != NULL)
    {
      /* We expect to immediately get data */
      if((len = read_socket(&conn, pcRxString, READBUF_SIZE, &size_header)) >= 0)
      {  
        if(strstr(pcRxString, "HTTP/1.0") != NULL)
          conn.version = VERSION_10;
        else if(strstr(pcRxString, "HTTP/1.1") != NULL)
          conn.version = VERSION_11;
        else
          conn.version = VERSION_UNKNOWN;    
        strcpy(pcRxStringMinus, pcRxString);
        minus(pcRxStringMinus);
        if((ptr = (char *)strstr(pcRxStringMinus, "content-length: ")) != NULL)
          conn.content_length  = (int)atol(&ptr[16]);
        if(conn.content_length)
        {  
          if(((ptr = (char *)strstr(pcRxStringMinus, "content-type: multipart/form-data")) != NULL)
           && ((ptr = (char *)strstr(ptr, "boundary=")) != NULL))
          {
            ptr+=9;
            ptr2 = conn.boundary;
            i = 0;
            while(*ptr && (*ptr != '\r') && (*ptr != '\n') && (*ptr != ';') && (i < 255))
              *ptr2++ = *ptr++;
            *ptr2 = 0;
          }
          ptr = (char *)pvPortMalloc2(size_header+conn.content_length+1);
          if(ptr != NULL)
          {
            memcpy(ptr, pcRxString, len);
            if(conn.content_length-len+size_header > 0)
              read_socket(&conn, &ptr[len], conn.content_length-len+size_header, NULL);
          }
          ptr2 = ptr;
        }      
        else
        {
          ptr = NULL;
          ptr2 = pcRxString;
        }
        conn.errno = 0;
        handle_url(&conn, ptr2);
        if(ptr != NULL)
          vPortFree2(ptr);    
      }
      vPortFree2(conn.response);
    }
    close(sock);
  }
}

/*------------------------------------------------------------*/

void vBasicWEBServer(void *pvParameters)
{
  static sock_msg msg;
  sock_msg *pmsg;
  char name[5];
  int sock, newsock, len = sizeof(struct sockaddr_in);
  static struct sockaddr_in address;
  int task;
  if(pvParameters);
  mbox = xQueueCreate(10, sizeof(sock_msg));
  for(task = 0; task < TASKS_SERVER; task++)
  {
    name[0] = 'H';
    name[1] = 'T';
    name[2] = '0' + (char)((task + 1) / 10);
    name[3] = '0' + (char)((task + 1) % 10);
    name[4] = '\0';
    xTaskCreate(vProcessConnection, (void *)name, configMINIMAL_STACK_SIZE, (void *)task, 9, NULL);
  }
  /* Create a new tcp connection handle */
  if((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
  {
    while(1)
      vTaskDelay(1);
  }
  else
  {
    int iOptVal = TRUE;
    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (char*)&iOptVal, sizeof(iOptVal));
    int nodelay = TRUE;
    setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char *)&nodelay, sizeof(nodelay));
  }  
  address.sin_family = AF_INET;
  address.sin_addr.s_addr = htonl(INADDR_ANY);
  address.sin_port = htons(webHTTP_PORT);
  if((bind(sock, (struct sockaddr *)&address, len) == -1)
   || (listen(sock, 5) == -1))
  {
    close(sock);
    while(1)
      vTaskDelay(1);
  }
  /* Loop forever */
  while(1)
  {
    len = sizeof(address);
    newsock = accept(sock, (struct sockaddr*)&address, &len);
    if(newsock != -1)
    {
      /* Service connection */
      if(mbox != NULL)
      {
        pmsg = &msg;
        pmsg->sock = newsock;
        xQueueSend(mbox, &pmsg, 100);
      }        
    }
    vTaskDelay(1);
  }
}

#endif /* LWIP */
